(function() {
  "use strict";

  angular
    .module("app.assets")
    .controller("VulnerabilityController", VulnerabilityController);

  VulnerabilityController.$inject = [
    "$rootScope",
    "$scope",
    "$filter",
    "$http",
    "$translate",
    "$window",
    "$timeout",
    "Utils",
    "FileSaver",
    "Blob",
    "$controller",
    "$state",
    "ContainerFactory",
    "NodeFactory",
    "PlatformFactory",
    "CveFactory",
    "$sanitize",
    "$interval",
    "CveProfileFactory",
    "Alertify"
  ];
  function VulnerabilityController(
    $rootScope,
    $scope,
    $filter,
    $http,
    $translate,
    $window,
    $timeout,
    Utils,
    FileSaver,
    Blob,
    $controller,
    $state,
    ContainerFactory,
    NodeFactory,
    PlatformFactory,
    CveFactory,
    $sanitize,
    $interval,
    CveProfileFactory,
    Alertify
  ) {
    //=======For preloading English translation file only=====
    $translate.instant("general.VERSION", {}, "", "en");
    //=======For preloading English translation file only=====

    let filter = "";
    let timer4Filter = null;
    let timer = null;
    let timer2 = null;

    $scope.dateTypes = [
      { id: "before", name: $translate.instant("general.BEFORE") },
      { id: "after", name: $translate.instant("general.AFTER") }
    ];

    $scope.matchTypes = [
      { id: "equal", name: "=" },
      {
        id: "contains",
        name: $translate.instant("admissionControl.operators.CONTAINS")
      }
    ];

    $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V3");

    activate();

    let baseCtl = $controller("BaseMultiClusterController", { $scope: $scope });

    baseCtl.doOnClusterRedirected($state.reload);

    function activate() {
      $scope.onAdvFilter = false;
      $scope.onContainer = false;
      $scope.entities = [];
      $scope.scores = [];
      $scope.filteredVulnerabilities = [];
      $scope.showLegend = false;
      $scope.progress = 0;
      $scope.progress2 = 0;
      $scope.isShowingAccepted = false;

      $scope.toggleLegend = () => ($scope.showLegend = !$scope.showLegend);

      $scope.clearSelection = () => {
        $scope.gridOptions.api.deselectAll();
        $scope.cve = null;
      };

      $scope.labelType = mode => {
        if (mode) {
          if (mode === "Discover") return "label-danger";
          else return "label-success";
        } else return "label-inverse";
      };

      $scope.toggleScore = version => {
        if (version === "v2") {
          $scope.gridOptions.columnApi.setColumnVisible("score", true);
          $scope.gridOptions.columnApi.setColumnVisible("score_v3", false);
          $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V2");
        } else {
          $scope.gridOptions.columnApi.setColumnVisible("score", false);
          $scope.gridOptions.columnApi.setColumnVisible("score_v3", true);
          $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V3");
        }
      };

      function initAdvFilter() {
        return {
          packageType: "all",
          severityType: "all",
          scoreType: "V3",
          publishedType: $scope.dateTypes[0],
          matchType: $scope.matchTypes[0],
          matchType4Ns: $scope.matchTypes[0],
          matchTypes: {
            Service: $scope.matchTypes[0],
            Image: $scope.matchTypes[0],
            Node: $scope.matchTypes[0],
            Container: $scope.matchTypes[0]
          },
          popup: { opened: false },
          dt: null,
          entities: ["Service", "Image", "Node", "Container"],
          entityType: "Service",
          serviceName: "",
          imageName: "",
          nodeName: "",
          containerName: "",
          selectedDomains: [],
          sliderV2: { minValue: 0, maxValue: 10 },
          sliderV3: { minValue: 0, maxValue: 10 }
        };
      }

      $scope.advFilter = initAdvFilter();
      $scope.REPORT_TABLE_ROW_LIMIT = REPORT_TABLE_ROW_LIMIT;
      $scope.setScoreType = function(scoreType) {
        $scope.advFilter.scoreType = scoreType;
        $timeout(function() {
          $scope.$broadcast("reCalcViewDimensions");
        }, 50);
      };
      $scope.setPublishedType = function(publishedType) {
        $scope.advFilter.publishedType = publishedType;
      };
      $scope.setMatchType = function(matchType) {
        $scope.advFilter.matchType = matchType;
        $scope.advFilter.matchTypes[$scope.advFilter.entityType] = matchType;
      };

      $scope.setMatchType4Ns = function(matchType) {
        $scope.advFilter.matchType4Ns = matchType;
        $scope.advFilter.matchTypes[$scope.advFilter.entityType] = matchType;
      };

      $scope.today = function() {
        $scope.advFilter.dt = new Date();
      };
      $scope.clear = function() {
        $scope.advFilter.dt = null;
      };
      $scope.format = "dd-MMMM-yyyy";
      $scope.dateOptions = {
        formatYear: "yy",
        maxDate: new Date(),
        minDate: new Date(2000, 1, 1),
        startingDay: 1
      };
      $scope.openDate = function() {
        $scope.advFilter.popup.opened = true;
      };

      $scope.namespaceFilter = function(workload) {
        if ($scope.advFilter.selectedDomains.length) {
          const container = $scope.workloadMap.get(workload.id);
          const nsNames = $scope.advFilter.selectedDomains.map(
            selectedDomain => selectedDomain.name
          );
          if (container && container.domain) {
            if ($scope.advFilter.matchType4Ns.id === "contains")
              return new RegExp(nsNames.join("|")).test(container.domain);
            else return nsNames.some(item => container.domain === item);
          } else return false;
        } else return true;
      };

      $scope.serviceFilter = function(workload) {
        if ($scope.advFilter.serviceName) {
          const container = $scope.workloadMap.get(workload.id);
          if (container && container.service_group) {
            if ($scope.advFilter.matchTypes.Service.id === "contains")
              return new RegExp($scope.advFilter.serviceName).test(
                container.service_group.substring(3)
              );
            else
              return (
                $scope.advFilter.serviceName ===
                container.service_group.substring(3)
              );
          } else return false;
        } else return true;
      };

      $scope.workloadFilter = function(workload) {
        if ($scope.advFilter.containerName) {
          const container = $scope.workloadMap.get(workload.id);
          if (container && container.display_name) {
            if ($scope.advFilter.matchTypes.Container.id === "contains")
              return new RegExp($scope.advFilter.containerName).test(
                container.display_name
              );
            else
              return $scope.advFilter.containerName === container.display_name;
          } else return false;
        } else return true;
      };

      $scope.setScore = function() {
        $scope.scores = [];
        setV2Score();
        setV3Score();
      };

      function setV2Score() {
        if ($scope.advFilter.sliderV2.minValue !== 0) {
          $scope.scores.push({
            id: "v2Min",
            name: `V2 > ${$scope.advFilter.sliderV2.minValue}`
          });
        }
        if ($scope.advFilter.sliderV2.maxValue !== 10) {
          $scope.scores.push({
            id: "v2Max",
            name: `V2 < ${$scope.advFilter.sliderV2.maxValue}`
          });
        }
      }
      function setV3Score() {
        if ($scope.advFilter.sliderV3.minValue !== 0) {
          $scope.scores.push({
            id: "v3Min",
            name: `V3 > ${$scope.advFilter.sliderV3.minValue}`
          });
        }
        if ($scope.advFilter.sliderV3.maxValue !== 10) {
          $scope.scores.push({
            id: "v3Max",
            name: `V3 < ${$scope.advFilter.sliderV3.maxValue}`
          });
        }
      }

      $scope.removeScore = function(scoreCard) {
        if (scoreCard.id === "v2Min") $scope.advFilter.sliderV2.minValue = 0;
        else if (scoreCard.id === "v2Max") {
          $scope.advFilter.sliderV2.maxValue = 10;
        } else if (scoreCard.id === "v3Min") {
          $scope.advFilter.sliderV3.minValue = 0;
        } else if (scoreCard.id === "v3Max") {
          $scope.advFilter.sliderV3.maxValue = 10;
        }
      };

      $scope.setEntity = function(entity) {
        $scope.advFilter.entityType = entity;
        $scope.advFilter.matchType = $scope.advFilter.matchTypes[entity];
      };

      $scope.setEntityName = function() {
        $scope.entities = [];

        let symbol = entityType =>
          $scope.advFilter.matchTypes[entityType].id === "contains" ? "~" : "=";
        if ($scope.advFilter.serviceName)
          $scope.entities.push({
            id: "svc",
            name: `Service ${symbol("Service")} ${$scope.advFilter.serviceName}`
          });
        if ($scope.advFilter.imageName)
          $scope.entities.push({
            id: "image",
            name: `Image ${symbol("Image")} ${$scope.advFilter.imageName}`
          });
        if ($scope.advFilter.nodeName)
          $scope.entities.push({
            id: "node",
            name: `Node ${symbol("Node")} ${$scope.advFilter.nodeName}`
          });
        if ($scope.advFilter.containerName)
          $scope.entities.push({
            id: "container",
            name: `Container ${symbol("Container")} ${
              $scope.advFilter.containerName
            }`
          });
      };

      $scope.removeEntity = entity => {
        if (entity.id === "ns") {
          $scope.advFilter.nsName = "";
        } else if (entity.id === "svc") {
          $scope.advFilter.serviceName = "";
        } else if (entity.id === "image") {
          $scope.advFilter.imageName = "";
        } else if (entity.id === "node") {
          $scope.advFilter.nodeName = "";
        } else if (entity.id === "container") {
          $scope.advFilter.containerName = "";
        }
      };

      CveFactory.prepareGrids();
      $scope.gridOptions = CveFactory.getGridOptions();
      $scope.gridOptions.onSelectionChanged = onCVEChanged;

      $scope.gridOptions.isExternalFilterPresent = isExternalFilterPresent;
      $scope.gridOptions.doesExternalFilterPass = doesExternalFilterPass;

      let $win = angular.element($window);
      $scope.gridOptions.onGridReady = params => {
        setTimeout(function() {
          params.api.sizeColumnsToFit();
          drawPeity();
        }, 500);
        $win.on("resize.#agGrid", function() {
          setTimeout(function() {
            params.api.sizeColumnsToFit();
            drawPeity();
          }, 300);
        });
      };
      $scope.gridOptions.onSortChanged = params => {
        drawPeity();
      };

      $scope.isAdvFilterOn = () => {
        return (
          $scope.advFilter.dt !== null ||
          $scope.advFilter.packageType !== "all" ||
          $scope.advFilter.severityType !== "all" ||
          $scope.advFilter.selectedDomains.length > 0 ||
          $scope.advFilter.serviceName ||
          $scope.advFilter.imageName ||
          $scope.advFilter.nodeName ||
          $scope.advFilter.containerName ||
          $scope.advFilter.sliderV2.minValue > 0 ||
          $scope.advFilter.sliderV2.maxValue < 10 ||
          $scope.advFilter.sliderV3.minValue > 0 ||
          $scope.advFilter.sliderV3.maxValue < 10
        );
      };

      function isExternalFilterPresent() {
        return $scope.isAdvFilterOn();
      }

      function checkEntity(matchType, entities, pattern, result) {
        const patterns = pattern.split(",").map(item => item.trim());
        const theEntity = entities.find(entity => {
          if (entity && entity.display_name) {
            if (matchType === "equal")
              return patterns.some(item => item === entity.display_name);
            else
              return new RegExp(patterns.join("|")).test(entity.display_name);
          } else {
            if (matchType === "equal")
              return patterns.some(item => item === entity);
            else return new RegExp(patterns.join("|")).test(entity);
          }
        });
        result = result && !!theEntity;
        return result;
      }

      function doesExternalFilterPass(node) {
        if (!$scope.isAdvFilterOn()) return true;
        else {
          let result = true;
          if ($scope.advFilter.dt) {
            if (
              $scope.advFilter.publishedType &&
              $scope.advFilter.publishedType.id === "before"
            )
              result =
                result &&
                node.data.published_timestamp <=
                  Math.floor($scope.advFilter.dt.getTime() / 1000);
            else
              result =
                result &&
                node.data.published_timestamp >=
                  Math.floor($scope.advFilter.dt.getTime() / 1000);
          }
          if ($scope.advFilter.severityType !== "all") {
            result =
              result && node.data.severity === $scope.advFilter.severityType;
          }
          if ($scope.advFilter.packageType === "withFix") {
            let packagePairs = Object.entries(node.data.Packages);
            if (packagePairs.length) {
              const hasFix = packagePairs.find(
                ([key, val]) =>
                  val.length && val.find(lib => !!lib.fixed_version)
              );
              result = result && !!hasFix;
            } else return false;
          }
          if ($scope.advFilter.packageType === "withoutFix") {
            let packagePairs = Object.entries(node.data.Packages);
            if (packagePairs.length) {
              const hasFix = packagePairs.find(
                ([key, val]) =>
                  val.length && val.find(lib => !!lib.fixed_version)
              );
              if (hasFix) return false;
            }
          }
          if ($scope.advFilter.containerName) {
            if (node.data.workloads.length) {
              result = checkEntity(
                $scope.advFilter.matchTypes["Container"].id,
                node.data.workloads,
                $scope.advFilter.containerName,
                result
              );
            } else return false;
          }
          if ($scope.advFilter.nodeName) {
            if (node.data.nodes.length) {
              result = checkEntity(
                $scope.advFilter.matchTypes["Node"].id,
                node.data.nodes,
                $scope.advFilter.nodeName,
                result
              );
            } else return false;
          }
          if ($scope.advFilter.imageName) {
            if (node.data.images.length) {
              result = checkEntity(
                $scope.advFilter.matchTypes["Image"].id,
                node.data.images,
                $scope.advFilter.imageName,
                result
              );
            } else return false;
          }
          if ($scope.advFilter.selectedDomains.length) {
            result = checkEntity(
              $scope.advFilter.matchType4Ns.id,
              node.data.domains,
              $scope.advFilter.selectedDomains
                .map(selectedDomain => selectedDomain.name)
                .join(","),
              result
            );
          }
          if ($scope.advFilter.serviceName) {
            if (node.data.services.length) {
              result = checkEntity(
                $scope.advFilter.matchTypes["Service"].id,
                node.data.services,
                $scope.advFilter.serviceName,
                result
              );
            } else return false;
          }
          if ($scope.advFilter.sliderV2.minValue) {
            result =
              result && node.data.score > $scope.advFilter.sliderV2.minValue;
          }
          if ($scope.advFilter.sliderV2.maxValue < 10) {
            result =
              result && node.data.score < $scope.advFilter.sliderV2.maxValue;
          }
          if ($scope.advFilter.sliderV3.minValue) {
            result =
              result && node.data.score_v3 > $scope.advFilter.sliderV3.minValue;
          }
          if ($scope.advFilter.sliderV3.maxValue < 10) {
            result =
              result && node.data.score_v3 < $scope.advFilter.sliderV3.maxValue;
          }
          return result;
        }
      }

      let getEntityName = function(count) {
        return Utils.getEntityName(
          count,
          $translate.instant("scan.COUNT_POSTFIX")
        );
      };
      const outOf = $translate.instant("enum.OUT_OF");
      const found = $translate.instant("enum.FOUND");

      const HIGH = $translate.instant("enum.HIGH");
      const MEDIUM = $translate.instant("enum.MEDIUM");

      $scope.graphHeight = $window.innerHeight - 240;

      angular.element($window).bind("resize", function() {
        $scope.graphHeight = $window.innerHeight - 240;
        $scope.$digest();
      });

      function onCVEChanged() {
        let selectedRows = $scope.gridOptions.api.getSelectedRows();
        $scope.cve = selectedRows[0];
        $scope.isAccepted =
          $scope.cve &&
          $scope.cve.tags &&
          $scope.cve.tags.some(tag => tag === "accepted");
        if ($scope.onCVE) {
          $scope.cveName = selectedRows[0].name;
          $scope.cveLink = selectedRows[0].link;
          $scope.cveDescription = selectedRows[0].description;
          $scope.cveVector =
            selectedRows[0].vectors_v3 || selectedRows[0].vectors;
          $scope.cveScoreV2 = selectedRows[0].score;
        }
        $scope.onContainer = false;
        $scope.$apply();
      }

      $scope.showDetails = function(event, cve) {
        event.stopPropagation();
        console.log(cve);
        $scope.cveName = cve.name;
        $scope.cveLink = cve.link;
        $scope.cveDescription = cve.description;
        $scope.cveVector = cve.vectors_v3 || cve.vectors;
        $scope.cveScoreV2 = cve.score;
        $scope.onCVE = true;
        $scope.onContainer = false;
        $scope.onHost = false;
        $timeout(function() {
          $scope.onCVE = false;
        }, 10000);
      };

      $scope.showFilter = function() {
        $scope.onAdvFilter = true;
        $scope.slider = {
          options: {
            floor: 0,
            ceil: 10,
            step: 1,
            showTicks: true,
            selectionBarGradient: {
              from: "#FC0",
              to: "red"
            }
          }
        };

        $timeout(function() {
          $scope.$broadcast("reCalcViewDimensions");
        }, 500);
      };

      $scope.onHover = (points, evt) => Utils.onHover(points, evt);

      $scope.applyAdvFilter = function(isFromQuickFilter = false) {
        $scope.progress = 0;
        $scope.filteredVulnerabilities = [];
        $scope.gridOptions.api.onFilterChanged();
        if (
          ($scope.advFilter.sliderV2.minValue > 0 ||
            $scope.advFilter.sliderV2.maxValue < 10) &&
          $scope.advFilter.sliderV3.minValue === 0 &&
          $scope.advFilter.sliderV3.maxValue === 10
        ) {
          $scope.gridOptions.columnApi.setColumnVisible("score", true);
          $scope.gridOptions.columnApi.setColumnVisible("score_v3", false);
          $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V2");
        } else {
          $scope.gridOptions.columnApi.setColumnVisible("score", false);
          $scope.gridOptions.columnApi.setColumnVisible("score_v3", true);
          $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V3");
        }
        drawPeity();
        $scope.gridOptions.api.forEachNodeAfterFilterAndSort(node => {
          $scope.filteredVulnerabilities.push(angular.copy(node.data));
        });
        if (!isFromQuickFilter) {
          sendData2Worker($scope.filteredVulnerabilities);
          if (
            $scope.advFilter.containerName ||
            $scope.advFilter.nodeName ||
            $scope.advFilter.imageName ||
            $scope.advFilter.selectedDomains.length > 0 ||
            $scope.advFilter.serviceName
          ) {
            sendServiceViewData2Worker(
              {
                workloadMap4Pdf: $scope.workloadMap4Pdf,
                hostMap4Pdf: $scope.hostMap4Pdf,
                platformMap4Pdf: $scope.platformMap4Pdf,
                imageMap4Pdf: $scope.imageMap4Pdf
              },
              $scope.filteredVulnerabilities,
              true,
              $scope.advFilter
            );
          } else {
            sendServiceViewData2Worker(
              {
                workloadMap4Pdf: $scope.workloadMap4Pdf,
                hostMap4Pdf: $scope.hostMap4Pdf,
                platformMap4Pdf: $scope.platformMap4Pdf,
                imageMap4Pdf: $scope.imageMap4Pdf
              },
              $scope.filteredVulnerabilities,
              false,
              $scope.advFilter
            );
          }
        }
        let filteredCount = $scope.gridOptions.api.getModel().rootNode
          .childrenAfterFilter.length;
        $scope.count = `${found} ${filteredCount} / ${
          $scope.vulnerabilities.length
        } ${getEntityName($scope.vulnerabilities.length)}`;

        $scope.onAdvFilter = false;
        $scope.clearSelection();
      };

      $scope.resetAdvFilter = function() {
        $scope.progress = 0;
        $scope.filteredVulnerabilities = [];
        $scope.advFilter = initAdvFilter();
        $scope.scores = [];
        $scope.entities = [];
        $scope.gridOptions.api.onFilterChanged();
        $scope.gridOptions.columnApi.setColumnVisible("score", false);
        $scope.gridOptions.columnApi.setColumnVisible("score_v3", true);
        $scope.scoreType = $translate.instant("scan.gridHeader.SCORE_V3");
        drawPeity();
        $scope.gridOptions.api.forEachNodeAfterFilterAndSort(node => {
          $scope.filteredVulnerabilities.push(angular.copy(node.data));
        });
        sendData2Worker($scope.filteredVulnerabilities);
        sendServiceViewData2Worker(
          {
            workloadMap4Pdf: $scope.workloadMap4Pdf,
            hostMap4Pdf: $scope.hostMap4Pdf,
            platformMap4Pdf: $scope.platformMap4Pdf,
            imageMap4Pdf: $scope.imageMap4Pdf
          },
          $scope.filteredVulnerabilities,
          false
        );
        $scope.count = `${$scope.vulnerabilities.length} ${getEntityName(
          $scope.vulnerabilities.length
        )}`;
        $scope.onAdvFilter = false;
        $scope.clearSelection();
      };

      $scope.onFilterChanged = function(value) {
        $scope.progress = 0;
        filter = value;
        $scope.filteredVulnerabilities = [];
        $scope.gridOptions.api.setQuickFilter(value);
        if (!value) $scope.applyAdvFilter(true);
        drawPeity();
        $scope.gridOptions.api.forEachNodeAfterFilterAndSort(node => {
          $scope.filteredVulnerabilities.push(angular.copy(node.data));
        });
        if (timer4Filter) {
          $timeout.cancel(timer4Filter);
        }
        timer4Filter = $timeout(function() {
          sendData2Worker($scope.filteredVulnerabilities);
        }, 2000);
        let filteredCount = $scope.gridOptions.api.getModel().rootNode
          .childrenAfterFilter.length;
        $scope.count =
          filteredCount === $scope.vulnerabilities.length || filteredCount === 0
            ? `${$scope.vulnerabilities.length} ${getEntityName(
                $scope.vulnerabilities.length
              )}`
            : `${found} ${filteredCount} / ${
                $scope.vulnerabilities.length
              } ${getEntityName($scope.vulnerabilities.length)}`;
      };

      const onCve = name => {
        $scope.gridOptions.api.forEachNode(function(node, index) {
          if (node.data.name === name) {
            node.setSelected(true);
            $scope.gridOptions.api.ensureNodeVisible(node, "middle");
            $scope.onContainer = false;
          }
        });
      };

      $scope.acceptVulnerability = function(event, data) {
        console.log(data);
        event.stopPropagation();
        let domainSet = new Set();
        if (data.workloads.length > 0) {
          data.workloads.forEach(workload => {
            workload.domains.forEach(domain => {
              domainSet.add(domain);
            });
          });
        }
        let payload = {
          config: {
            entries: [
              {
                name: data.name,
                days: 0,
                comment: `Accepted by ${
                  $rootScope.user.token.username
                } at ${$filter("date")(
                  new Date(),
                  "MMM dd, y HH:mm:ss"
                )} from Vulnerabilities page`,
                images: [], //data.images.map(image => image.display_name),
                domains: [] //Array.from(domainSet)
              }
            ],
            name: "default"
          }
        };

        CveProfileFactory.addCveProfile(payload)
          .then(res => {
            Alertify.set({ delay: ALERTIFY_SUCCEED_DELAY });
            Alertify.success($translate.instant("cveProfile.msg.ADD_OK"));
          })
          .catch(err => {
            if (USER_TIMEOUT.indexOf(err.status) < 0) {
              Alertify.set({ delay: ALERTIFY_ERROR_DELAY });
              Alertify.error(
                Utils.getAlertifyMsg(
                  err,
                  $translate.instant("cveProfile.msg.ADD_NG"),
                  false
                )
              );
            }
          });
      };

      $scope.loadTags = function(query) {
        let list = $scope.namespaces;
        return query ? list.filter(Utils.createFilter(query)) : [];
      };

      $scope.showWorkload = id => {
        ContainerFactory.getContainer(id).then(container => {
          $scope.container = container;
          $scope.onContainer = true;
          $scope.onCVE = false;
          $scope.onHost = false;
        });
      };

      $scope.showHost = id => {
        NodeFactory.getHost(id).then(host => {
          $scope.host = host;
          $scope.onHost = true;
          $scope.onContainer = false;
          $scope.onCVE = false;
        });
      };

      function drawPeity() {
        setTimeout(function() {
          $("span.pie").peity("pie");
        }, 0);
      }

      function prepareChartParams() {
        $scope.sdColors = ["#ef5350", "#ff9800"];
        $scope.sdName = [HIGH, MEDIUM];
        $scope.sdLegend = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: $translate.instant("scan.report.others.SEVERITY_DIS")
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          cutoutPercentage: 60,
          elements: {
            arc: {
              borderWidth: 0
            }
          }
        };
        $scope.sdOverride = [{}];
        $scope.entLegend = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: $translate.instant("scan.report.others.TARGET_DIS")
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          cutoutPercentage: 60,
          elements: {
            arc: {
              borderWidth: 0
            }
          }
        };
        $scope.entOverride = [{}];
        $scope.series = ["Platform", "Image", "Node", "Container"];
        $scope.colors = ["#f22d3a", "#86aec2", "#4D5360", "#36A2EB"];
        $scope.options = {
          onClick: function(e) {
            const element = this.getElementAtEvent(e);
            if (element.length) {
              onCve(element[0]._model.label);
            }
          },
          maintainAspectRatio: false,
          title: {
            display: true,
            text: $translate.instant("scan.report.others.TOP_IMPACTFUL_VUL")
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                ticks: {
                  beginAtZero: true
                }
              }
            ],
            xAxes: [
              {
                barPercentage: 0.4,
                ticks: {
                  display: false
                }
              }
            ]
          }
        };
        $scope.options4Pdf = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: "Top Impactful Vulnerabilities"
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                ticks: {
                  beginAtZero: true
                }
              }
            ],
            xAxes: [
              {
                barPercentage: 0.4,
                ticks: {
                  display: true
                }
              }
            ]
          }
        };
        $scope.cveSeries = [HIGH, MEDIUM];
        $scope.cveColors = ["#ef5350", "#ff9800"];
        $scope.cveOverride = [
          {
            borderWidth: 1
          },
          {
            borderWidth: 1
          }
        ];
        $scope.cveOptions = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: $translate.instant("scan.report.others.TOP_VULNERABLE_IMAGES")
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                barPercentage: 0.4,
                barThickness: 6,
                borderWidth: 0,
                ticks: {
                  display: true,
                  callback: function(value) {
                    return Utils.shortenString(value, 35);
                  }
                }
              }
            ],
            xAxes: [
              {
                ticks: {
                  callback: function(value) {
                    if (value % 1 === 0) {
                      return value;
                    }
                  },
                  beginAtZero: true
                }
              }
            ]
          }
        };
        $scope.cveOptions4Pdf = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: "Top Vulnerable Images"
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                barPercentage: 0.4,
                barThickness: 6,
                borderWidth: 0,
                ticks: {
                  display: true
                }
              }
            ],
            xAxes: [
              {
                ticks: {
                  callback: function(value) {
                    if (value % 1 === 0) {
                      return value;
                    }
                  },
                  beginAtZero: true
                }
              }
            ]
          }
        };
        $scope.cveHostOptions = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: $translate.instant("scan.report.others.TOP_VULNERABLE_HOSTS")
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                barPercentage: 0.4,
                barThickness: 6,
                borderWidth: 0,
                ticks: {
                  display: true
                }
              }
            ],
            xAxes: [
              {
                ticks: {
                  callback: function(value) {
                    if (value % 1 === 0) {
                      return value;
                    }
                  },
                  beginAtZero: true
                }
              }
            ]
          }
        };
        $scope.cveHostOptions4Pdf = {
          maintainAspectRatio: false,
          title: {
            display: true,
            text: "Top Vulnerable Nodes"
          },
          legend: {
            display: true,
            labels: {
              boxWidth: 12
            }
          },
          scales: {
            yAxes: [
              {
                ticks: {
                  callback: function(value) {
                    if (value % 1 === 0) {
                      return value;
                    }
                  },
                  beginAtZero: true
                }
              }
            ],
            xAxes: [
              {
                barPercentage: 0.4,
                ticks: {
                  display: true
                }
              }
            ]
          }
        };
      }

      $scope.toggleShowingAcceptedVuls = function(isShowingAccepted) {
        $scope.isShowingAccepted = !isShowingAccepted;
        $scope.refresh($scope.isShowingAccepted);
      };

      $scope.refresh = function(isShowingAccepted = false) {
        $scope.cvesErr = false;
        $scope.onHost = false;
        $scope.onContainer = false;
        $scope.onCVE = false;
        $scope.cve = null;

        Promise.all([
          ContainerFactory.getWorkloadMap(),
          NodeFactory.getHostMap(),
          PlatformFactory.getPlatformMap(),
          CveFactory.getCveReport(isShowingAccepted)
        ])
          .then(([workloadMaps, nodeMap, platformMap, report]) => {
            $scope.vulnerabilities = report.cve;
            $scope.workloadMap4Pdf = workloadMaps.workloadMap4Pdf;
            $scope.imageMap4Pdf = workloadMaps.imageMap4Pdf;
            $scope.hostMap4Pdf = nodeMap;
            $scope.platformMap4Pdf = platformMap;
            $scope.vulnerabilities4Pdf = angular.copy(report.cve);
            console.log(
              "Maps4Pdf:",
              $scope.workloadMap4Pdf,
              $scope.hostMap4Pdf,
              $scope.platformMap4Pdf,
              $scope.imageMap4Pdf
            );
            $scope.progress2 = 0;
            sendServiceViewData2Worker(
              {
                workloadMap4Pdf: $scope.workloadMap4Pdf,
                hostMap4Pdf: $scope.hostMap4Pdf,
                platformMap4Pdf: $scope.platformMap4Pdf,
                imageMap4Pdf: $scope.imageMap4Pdf
              },
              $scope.vulnerabilities4Pdf,
              false
            );
            $scope.workloadMap = workloadMaps.workloadMap;
            $scope.vulnerabilities = Utils.setRisks(
              $scope.vulnerabilities,
              $scope.workloadMap
            );
            $scope.gridOptions.api.setRowData($scope.vulnerabilities);
            $scope.gridOptions.api.sizeColumnsToFit();
            $timeout(() => {
              $scope.gridOptions.api.getRowNode(0).setSelected(true);
            }, 200);
            $scope.count = `${$scope.vulnerabilities.length} ${getEntityName(
              $scope.vulnerabilities.length
            )}`;
            $scope.onFilterChanged(filter);
            $scope.gridOptions.onBodyScroll = function(params) {
              drawPeity();
            };
            drawPeity();

            $scope.labels = report.topCve.map(cve => cve.name);
            const platforms = report.topCve.map(cve => cve.platforms.length);
            const images = report.topCve.map(cve => cve.images.length);
            const nodes = report.topCve.map(cve => cve.nodes.length);
            const containers = report.topCve.map(cve => cve.workloads.length);

            prepareChartParams();
            const countDis = report.counts;
            $scope.sdData = [countDis.high, countDis.medium];
            $scope.entData = [
              countDis.platform,
              countDis.image,
              countDis.node,
              countDis.container
            ];
            $scope.data = [platforms, images, nodes, containers];

            $scope.cveHostLabels = report.topNodes.map(host => host[0]);
            const highs4Host = report.topNodes.map(host => host[1].high);
            const mediums4Host = report.topNodes.map(host => host[1].medium);
            $scope.cveHostData = [highs4Host, mediums4Host];
            console.log("$scope.cveHostLabels:", $scope.cveHostLabels);
            console.log("$scope.cveHostData:", $scope.cveHostData);

            $scope.cveLabels = report.topImages.map(image => image[0]);
            const highs = report.topImages.map(image => image[1].high);
            const mediums = report.topImages.map(image => image[1].medium);
            $scope.cveData = [highs, mediums];
          })
          .catch(function(err) {
            $scope.vulnerabilities = [];
            if (err.status === 404 || err.status === 403) {
              $scope.gridOptions.overlayNoRowsTemplate = `<span class="overlay">${$translate.instant(
                "general.NO_ROWS"
              )}</span>`;
            } else {
              $scope.cvesErr = true;
              $scope.gridOptions.overlayNoRowsTemplate = Utils.getOverlayTemplateMsg(
                err
              );
            }
            $scope.gridOptions.api.setRowData();
            prepareChartParams();
            $scope.sdData = [[], []];
            $scope.entData = [[], [], [], []];
            $scope.data = [[], [], [], []];
            $scope.cveData = [[], []];
            $scope.count = `${$scope.vulnerabilities.length} ${getEntityName(
              0
            )}`;
          });

        CveFactory.getDomains()
          .then(res => {
            const resourceList = ["_images", "_nodes", "_containers"];
            $scope.namespaces = res.data.domains
              .filter(domain => !resourceList.includes(domain.name))
              .map(domain => domain.name);
          })
          .catch(err => {
            $scope.namespaces = [];
          });
      };

      $scope.refresh();

      $scope.exportCsv = function(cveEntry) {
        let vulnerabilities4Csv = [];
        const prepareEntryData = function(cve) {
          cve.description = cve.description ? `${cve.description.replace(/\"/g, "'")}` : "";
          if (cve.platforms && Array.isArray(cve.platform)) {
            cve.platforms = cve.platforms.reduce(
              (acc, curr) => acc + curr.display_name + " ",
              ""
            );
          }
          if (cve.images && Array.isArray(cve.images)) {
            cve.images = cve.images.reduce(
              (acc, curr) => acc + curr.display_name + " ",
              ""
            );
          }
          if (cve.nodes && Array.isArray(cve.nodes)) {
            cve.nodes = cve.nodes.reduce(
              (acc, curr) => acc + curr.display_name + " ",
              ""
            );
          }
          if (cve.workloads && Array.isArray(cve.workloads)) {
            let filteredWorkload = cve.workloads.filter(workload =>
              $scope.namespaceFilter(workload)
            );

            filteredWorkload = filteredWorkload.filter(workload =>
              $scope.serviceFilter(workload)
            );

            filteredWorkload = filteredWorkload.filter(workload =>
              $scope.workloadFilter(workload)
            );

            cve.workloads = Array.from(
              filteredWorkload.reduce(
                (acc, curr) => acc.add(curr.display_name),
                new Set()
              )
            ).join(" ");

            cve.services = Array.from(
              filteredWorkload.reduce(
                (acc, curr) => acc.add(curr.service),
                new Set()
              )
            ).join(" ");

            cve.domains = Array.from(
              filteredWorkload.reduce(
                (acc, curr) => acc.add(curr.domain),
                new Set()
              )
            ).join(" ");

            cve.images = cve.images.concat(Array.from(
              filteredWorkload.reduce(
                (acc, curr) => acc.add(curr.image),
                new Set()
              )
            ).join(" "));
            console.log(
              "cve.workloads: ",
              cve.workloads,
              "cve.services:",
              cve.services,
              "cve.domains:",
              cve.domains,
              "cve.images:",
              cve.images
            );
          }

          if (cve.Packages) {
            cve["package_versions->fixed_version"] = Object.entries(
              cve.Packages
            )
              .map(([k, v]) => {
                return `${k}:(${v.reduce(
                  (acc, curr) =>
                    acc +
                    curr.package_version +
                    " -> " +
                    (curr.fixed_version || "N/A") +
                    " ",
                  ""
                )})`;
              })
              .join(" ");
          }
          cve.last_modified_datetime = $filter("date")(
            angular.copy(cve.last_modified_timestamp) * 1000,
            "MMM dd, y HH:mm:ss"
          ).toString();
          cve.published_datetime = $filter("date")(
            angular.copy(cve.published_timestamp) * 1000,
            "MMM dd, y HH:mm:ss"
          ).toString();
          delete cve.package_versions;
          return cve;
        };

        const listAssets = function(entryData) {
          let imageList = entryData.images.map(image => image.display_name);
          let workloadList = entryData.workloads.map(workload => workload.display_name);
          let serviceList = entryData.services;
          let domainList = entryData.domains;
          let nodeList = entryData.nodes.map(node => node.display_name);
          let platformList = entryData.platforms.map(platform => platform.display_name);
          let pv2fvList = Object.entries(
            entryData.Packages
          )
            .map(([k, v]) => {
              return `${k}:(${v.reduce(
                (acc, curr) =>
                  acc +
                  curr.package_version +
                  " -> " +
                  (curr.fixed_version || "N/A") +
                  " ",
                ""
              )})`;
            });
          let maxRow4Entry = Math.max(
            imageList.length,
            workloadList.length,
            serviceList.length,
            domainList.length,
            nodeList.length,
            platformList.length,
            pv2fvList.length
          );
          maxRow4Entry = maxRow4Entry === 0 ? 1 : maxRow4Entry;
          let rows = [];
          for (let i = 0; i < maxRow4Entry; i++) {
            rows.push({
              description: i === 0 ? entryData.description : "",
              link: i === 0 ? entryData.link : "",
              name: i === 0 ? entryData.name : "",
              severity: i === 0 ? entryData.severity : "",
              score: i === 0 ? entryData.score : "",
              score_v3: i === 0 ? entryData.score_v3 : "",
              vectors: i === 0 ? entryData.vectors : "",
              vectors_v3: i === 0 ? entryData.vectors_v3 : "",
              platforms: i > platformList.length - 1 ? "" : platformList[i],
              nodes: i > nodeList.length - 1 ? "" : nodeList[i],
              domains: i > domainList.length - 1 ? "" : domainList[i],
              services: i > serviceList.length - 1 ? "" : serviceList[i],
              workloads: i > workloadList.length - 1 ? "" : workloadList[i],
              images: i > imageList.length - 1 ? "" : imageList[i],
              "package_versions->fixed_version": i > pv2fvList.length - 1 ? "" : pv2fvList[i],
              last_modified_datetime:
                i === 0 ? $filter("date")(entryData.last_modified_timestamp * 1000, "MMM dd, y HH:mm:ss") : "",
              published_datetime: i === 0 ? $filter("date")(entryData.published_timestamp * 1000, "MMM dd, y HH:mm:ss") : ""
            });
          }
          return rows;
        };

        const resolveExcelCellLimit = function(entryData) {
          let maxLen = Math.max(
            entryData.images.length,
            entryData.workloads.length,
            entryData.services.length,
            entryData.domains.length,
            entryData["package_versions->fixed_version"].length
          );
          let maxRow4Entry = Math.ceil(maxLen / EXCEL_CELL_LIMIT);
          maxRow4Entry = maxRow4Entry === 0 ? 1 : maxRow4Entry;
          let rows = [];
          for (let i = 0; i < maxRow4Entry; i++) {
            rows.push({
              description: i === 0 ? entryData.description : "",
              link: i === 0 ? entryData.link : "",
              name: i === 0 ? entryData.name : "",
              severity: i === 0 ? entryData.severity : "",
              score: i === 0 ? entryData.score : "",
              score_v3: i === 0 ? entryData.score_v3 : "",
              vectors: i === 0 ? entryData.vectors : "",
              vectors_v3: i === 0 ? entryData.vectors_v3 : "",
              platforms: i === 0 ? entryData.platforms : "",
              nodes: i === 0 ? entryData.nodes : "",
              domains:
                entryData.domains.length > EXCEL_CELL_LIMIT * (i + 1)
                  ? entryData.domains.substring(
                      EXCEL_CELL_LIMIT * i,
                      EXCEL_CELL_LIMIT * (i + 1)
                    )
                  : entryData.domains.substring(EXCEL_CELL_LIMIT * i),
              services:
                entryData.services.length > EXCEL_CELL_LIMIT * (i + 1)
                  ? entryData.services.substring(
                      EXCEL_CELL_LIMIT * i,
                      EXCEL_CELL_LIMIT * (i + 1)
                    )
                  : entryData.services.substring(EXCEL_CELL_LIMIT * i),
              workloads:
                entryData.workloads.length > EXCEL_CELL_LIMIT * (i + 1)
                  ? entryData.workloads.substring(
                      EXCEL_CELL_LIMIT * i,
                      EXCEL_CELL_LIMIT * (i + 1)
                    )
                  : entryData.workloads.substring(EXCEL_CELL_LIMIT * i),
              images:
                entryData.images.length > EXCEL_CELL_LIMIT * (i + 1)
                  ? entryData.images.substring(
                      EXCEL_CELL_LIMIT * i,
                      EXCEL_CELL_LIMIT * (i + 1)
                    )
                  : entryData.images.substring(EXCEL_CELL_LIMIT * i),
              "package_versions->fixed_version":
                entryData["package_versions->fixed_version"].length >
                EXCEL_CELL_LIMIT * (i + 1)
                  ? entryData["package_versions->fixed_version"].substring(
                      EXCEL_CELL_LIMIT * i,
                      EXCEL_CELL_LIMIT * (i + 1)
                    )
                  : entryData["package_versions->fixed_version"].substring(
                      EXCEL_CELL_LIMIT * i
                    ),
              last_modified_datetime:
                i === 0 ? entryData.last_modified_datetime : "",
              published_datetime: i === 0 ? entryData.published_datetime : ""
            });
          }
          console.log("rows", rows);
          return rows;
        };

        if (
          $scope.filteredVulnerabilities &&
          $scope.filteredVulnerabilities.length > 0
        ) {
          if (cveEntry) {
            vulnerabilities4Csv = vulnerabilities4Csv.concat(listAssets(cveEntry));
          } else {
            $scope.filteredVulnerabilities.forEach(cve => {
              let entryData = prepareEntryData(angular.copy(cve));
              vulnerabilities4Csv = vulnerabilities4Csv.concat(resolveExcelCellLimit(entryData));
            });
          }

          let csv = Utils.arrayToCsv(vulnerabilities4Csv);
          let blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
          let filename =
            cveEntry && cveEntry.name ?
            `${cveEntry.name}_${Utils.parseDatetimeStr(
              new Date()
            )}.csv` :
            `vulnerabilities_${Utils.parseDatetimeStr(
              new Date()
            )}.csv`;
          FileSaver.saveAs(blob, filename);
        }
      };

      /*==============================================================================
      PDF(Service View) code start
      ================================================================================*/

      const _webWorkerJob2 = function() {
        const prepareData4Filtered = function(
          masterData,
          vuls,
          advFilter,
          isAdvFilterOn
        ) {
          let grids = [[], [], [], []];
          let workloadMap4FilteredPdf = {};
          let hostMap4FilteredPdf = {};
          let imageMap4FilteredPdf = {};
          vuls.forEach(vul => {
            if (
              vul.workloads &&
              Array.isArray(vul.workloads) &&
              vul.workloads.length > 0 &&
              (advFilter.containerName ||
                advFilter.serviceName ||
                advFilter.selectedDomains.length > 0)
            ) {
              let vulWorkloadInit = {
                pod_name: "",
                domain: "",
                applications: [],
                policy_mode: "",
                service_group: "",
                scanned_at: "",
                high: 0,
                medium: 0,
                evaluation: 0,
                vulnerabilites: []
              };
              let patterns = advFilter.containerName
                .split(",")
                .map(item => item.trim())
                .filter(item => item.length > 0);
              let servicePatterns = advFilter.serviceName
                .split(",")
                .map(item => item.trim())
                .filter(item => item.length > 0);
              let domainPatterns = advFilter.selectedDomains
                .map(item => item.name.trim())
                .filter(item => item.length > 0);
              console.log("domainPatterns: ", servicePatterns);
              vul.workloads.forEach(workload => {
                if (masterData.workloadMap4Pdf[workload.id])
                  console.log(
                    "workloads: ",
                    masterData.workloadMap4Pdf[workload.id].service_group,
                    new RegExp(domainPatterns.join("|")).test(
                      masterData.workloadMap4Pdf[workload.id].service_group
                    )
                  );
                if (
                  ((patterns.length > 0 &&
                    new RegExp(patterns.join("|")).test(
                      workload.display_name
                    )) ||
                    patterns.length === 0) &&
                  ((servicePatterns.length > 0 &&
                    masterData.workloadMap4Pdf[workload.id] &&
                    new RegExp(servicePatterns.join("|")).test(
                      masterData.workloadMap4Pdf[
                        workload.id
                      ].service_group.substring(3)
                    )) ||
                    servicePatterns.length === 0) &&
                  ((domainPatterns.length > 0 &&
                    masterData.workloadMap4Pdf[workload.id] &&
                    new RegExp(domainPatterns.join("|")).test(
                      masterData.workloadMap4Pdf[workload.id].domain
                    )) ||
                    domainPatterns.length === 0)
                ) {
                  console.log(
                    "workloads_1: ",
                    masterData.workloadMap4Pdf[workload.id].service_group,
                    new RegExp(domainPatterns.join("|")).test(
                      masterData.workloadMap4Pdf[workload.id].service_group
                    )
                  );
                  let vulWorkload = workloadMap4FilteredPdf[workload.id];
                  if (vulWorkload) {
                    vulWorkload.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulWorkload.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulWorkload.evaluation =
                      vulWorkload.high > 0 || vulWorkload.medium > 0 ? 1 : 0;
                    vulWorkload.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  } else {
                    vulWorkload = JSON.parse(JSON.stringify(vulWorkloadInit));
                    let workloadInfo = masterData.workloadMap4Pdf[workload.id];
                    vulWorkload.pod_name = workload.display_name;
                    vulWorkload.domain = workloadInfo.domain;
                    vulWorkload.applications = workloadInfo.applications;
                    vulWorkload.policy_mode = workload.policy_mode;
                    vulWorkload.service_group = workloadInfo.service_group;
                    vulWorkload.scanned_at = workloadInfo.scanned_at;
                    vulWorkload.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulWorkload.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulWorkload.evaluation =
                      vulWorkload.high > 0 || vulWorkload.medium > 0 ? 1 : 0;
                    vulWorkload.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  }
                  workloadMap4FilteredPdf[workload.id] = vulWorkload;
                }
              });
            }
            if (
              vul.nodes &&
              Array.isArray(vul.nodes) &&
              vul.nodes.length > 0 &&
              advFilter.nodeName
            ) {
              let vulHostInit = {
                name: "",
                os: "",
                kernel: "",
                cpus: 0,
                memory: 0,
                containers: 0,
                policy_mode: "",
                scanned_at: "",
                high: 0,
                medium: 0,
                evaluation: 0,
                vulnerabilites: []
              };
              let patterns = advFilter.nodeName
                .split(",")
                .map(item => item.trim());
              vul.nodes.forEach(host => {
                if (new RegExp(patterns.join("|")).test(host.display_name)) {
                  let vulHost = hostMap4FilteredPdf[host.id];
                  if (vulHost) {
                    vulHost.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulHost.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulHost.evaluation =
                      vulHost.high > 0 || vulHost.medium > 0 ? 1 : 0;
                    vulHost.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  } else {
                    vulHost = JSON.parse(JSON.stringify(vulHostInit));
                    let hostInfo = masterData.hostMap4Pdf[host.id];
                    vulHost.name = host.display_name;
                    vulHost.os = hostInfo.os;
                    vulHost.kernel = hostInfo.kernel;
                    vulHost.cpus = hostInfo.cpus;
                    vulHost.memory = hostInfo.memory;
                    vulHost.containers = hostInfo.containers;
                    vulHost.policy_mode = host.policy_mode;
                    vulHost.scanned_at = host.scanned_at;
                    vulHost.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulHost.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulHost.evaluation =
                      vulHost.high > 0 || vulHost.medium > 0 ? 1 : 0;
                    vulHost.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  }
                  hostMap4FilteredPdf[host.id] = vulHost;
                }
              });
            }
            if (
              vul.images &&
              Array.isArray(vul.images) &&
              vul.images.length > 0 &&
              advFilter.imageName
            ) {
              let vulImageInit = {
                image_name: "",
                high: 0,
                medium: 0,
                vulnerabilites: []
              };
              let patterns = advFilter.imageName
                .split(",")
                .map(item => item.trim());
              vul.images.forEach(image => {
                if (new RegExp(patterns.join("|")).test(image.display_name)) {
                  let vulImage = imageMap4FilteredPdf[image.id];
                  if (vulImage) {
                    vulImage.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulImage.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulImage.evaluation =
                      vulImage.high > 0 || vulImage.medium > 0 ? 1 : 0;
                    vulImage.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  } else {
                    vulImage = JSON.parse(JSON.stringify(vulImageInit));
                    vulImage.image_name = image.display_name;
                    vulImage.high +=
                      vul.severity.toLowerCase() === "high" ? 1 : 0;
                    vulImage.medium +=
                      vul.severity.toLowerCase() === "high" ? 0 : 1;
                    vulImage.evaluation =
                      vulImage.high > 0 || vulImage.medium > 0 ? 1 : 0;
                    vulImage.vulnerabilites.push({
                      text: vul.name,
                      style:
                        vul.severity.toLowerCase() === "high"
                          ? "danger"
                          : "warning"
                    });
                  }
                  imageMap4FilteredPdf[image.id] = vulImage;
                }
              });
            }
          });
          grids[0] = Object.values(workloadMap4FilteredPdf);
          grids[1] = Object.values(hostMap4FilteredPdf);
          grids[3] = Object.values(imageMap4FilteredPdf);
          return grids;
        };
        const mergeData4NonFiltered = function(
          masterData,
          vuls,
          isAdvFilterOn
        ) {
          console.log("Input: ", JSON.parse(JSON.stringify(masterData)), vuls);
          let grids = [[], [], [], []]; //workloads, hosts, platforms, images
          vuls.forEach(vul => {
            if (
              vul.workloads &&
              Array.isArray(vul.workloads) &&
              vul.workloads.length > 0
            ) {
              vul.workloads.forEach(workload => {
                let vulWorkload = masterData.workloadMap4Pdf[workload.id];
                if (vulWorkload) {
                  vulWorkload.vulnerabilites.push({
                    text: vul.name,
                    style:
                      vul.severity.toLowerCase() === "high"
                        ? "danger"
                        : "warning"
                  });
                  vulWorkload.high +=
                    vul.severity.toLowerCase() === "high" ? 1 : 0;
                  vulWorkload.medium +=
                    vul.severity.toLowerCase() === "high" ? 0 : 1;
                  vulWorkload.evaluation =
                    vulWorkload.high > 0 || vulWorkload.medium > 0 ? 1 : 0;
                  masterData.workloadMap4Pdf[workload.id] = vulWorkload;
                }
              });
            }
            if (vul.nodes && Array.isArray(vul.nodes) && vul.nodes.length > 0) {
              vul.nodes.forEach(host => {
                let vulHost = masterData.hostMap4Pdf[host.id];
                if (vulHost) {
                  vulHost.vulnerabilites.push({
                    text: vul.name,
                    style:
                      vul.severity.toLowerCase() === "high"
                        ? "danger"
                        : "warning"
                  });
                  vulHost.high += vul.severity.toLowerCase() === "high" ? 1 : 0;
                  vulHost.medium +=
                    vul.severity.toLowerCase() === "high" ? 0 : 1;
                  vulHost.evaluation =
                    vulHost.high > 0 || vulHost.medium > 0 ? 1 : 0;
                  masterData.hostMap4Pdf[host.id] = vulHost;
                }
              });
            }
            if (
              vul.platforms &&
              Array.isArray(vul.platforms) &&
              vul.platforms.length > 0
            ) {
              vul.platforms.forEach(platform => {
                let vulPlatform = masterData.platformMap4Pdf[platform.id];
                if (vulPlatform) {
                  vulPlatform.vulnerabilites.push({
                    text: vul.name,
                    style:
                      vul.severity.toLowerCase() === "high"
                        ? "danger"
                        : "warning"
                  });
                  vulPlatform.high +=
                    vul.severity.toLowerCase() === "high" ? 1 : 0;
                  vulPlatform.medium +=
                    vul.severity.toLowerCase() === "high" ? 0 : 1;
                  masterData.platformMap4Pdf[platform.id] = vulPlatform;
                }
              });
            }
            if (
              vul.images &&
              Array.isArray(vul.images) &&
              vul.images.length > 0
            ) {
              let otherVulImageInit = {
                image_id: "",
                image_name: "",
                high: 0,
                medium: 0,
                evaluation: 0,
                vulnerabilites: []
              };
              vul.images.forEach(image => {
                let vulImage = masterData.imageMap4Pdf[image.id];
                if (vulImage) {
                  vulImage.vulnerabilites.push({
                    text: vul.name,
                    style:
                      vul.severity.toLowerCase() === "high"
                        ? "danger"
                        : "warning"
                  });
                  vulImage.high +=
                    vul.severity.toLowerCase() === "high" ? 1 : 0;
                  vulImage.medium +=
                    vul.severity.toLowerCase() === "high" ? 0 : 1;
                  vulImage.evaluation =
                    vulImage.high > 0 || vulImage.medium > 0 ? 1 : 0;
                  masterData.imageMap4Pdf[image.id] = vulImage;
                } else {
                  let otherVulImage = JSON.parse(
                    JSON.stringify(otherVulImageInit)
                  );
                  otherVulImage.image_id = image.id;
                  otherVulImage.image_name = image.display_name;
                  otherVulImage.vulnerabilites.push({
                    text: vul.name,
                    style:
                      vul.severity.toLowerCase() === "high"
                        ? "danger"
                        : "warning"
                  });
                  otherVulImage.high +=
                    vul.severity.toLowerCase() === "high" ? 1 : 0;
                  otherVulImage.medium +=
                    vul.severity.toLowerCase() === "high" ? 0 : 1;
                  otherVulImage.evaluation =
                    otherVulImage.high > 0 || otherVulImage.medium > 0 ? 1 : 0;
                  masterData.imageMap4Pdf[image.id] = otherVulImage;
                }
              });
            }
          });
          grids[0] = Object.values(masterData.workloadMap4Pdf);
          grids[1] = Object.values(masterData.hostMap4Pdf);
          grids[2] = Object.values(masterData.platformMap4Pdf);
          grids[3] = Object.values(masterData.imageMap4Pdf);
          console.log("grids: ", JSON.parse(JSON.stringify(grids)));
          return grids;
        };

        const prepareDetails = function(
          masterData,
          vuls,
          isFiltered,
          advFilter
        ) {
          console.log(
            "Input: ",
            JSON.parse(JSON.stringify(masterData)),
            vuls,
            isFiltered,
            advFilter
          );
          if (isFiltered) {
            return prepareData4Filtered(masterData, vuls, advFilter);
          } else {
            return mergeData4NonFiltered(masterData, vuls);
          }
        };

        const _getScore = function(item, metadata) {
          let scoreList = {};
          let scoreStyle = "";
          if (
            item.severity.toLowerCase() === "high" ||
            item.severity.toLowerCase() === "critical"
          ) {
            scoreStyle = "danger";
          } else if (
            item.severity.toLowerCase() === "medium" ||
            item.severity.toLowerCase() === "warning"
          ) {
            scoreStyle = "warning";
          } else {
            scoreStyle = "info";
          }
          scoreList.ul = [
            { text: `${metadata.data.v2}: ${item.score}`, style: scoreStyle },
            {
              text: `${metadata.data.v3}: ${item.score_v3}`,
              style: scoreStyle
            }
          ];
          return scoreList;
        };

        const _getPackage = function(item, metadata, isFullList) {
          let details = [];
          let packages = Object.entries(item.Packages);
          let originalPackageCount = packages.length;
          if (!isFullList) {
            packages = packages.slice(0, 3);
          }
          packages.forEach(([k, v]) => {
            let packageName = {};
            if (k) {
              packageName = {
                text: [k]
              };
            }

            let version;
            let impactedVersion = {};
            impactedVersion.ul = [];
            let fixedVersion = {};
            fixedVersion.ul = [];

            if (v && Array.isArray(v)) {
              v.forEach(package_version => {
                impactedVersion.ul.push(package_version.package_version);
                fixedVersion.ul.push(
                  package_version.fixed_version
                    ? package_version.fixed_version
                    : "N/A"
                );
              });
            }
            version = {
              table: {
                widths: ["50%", "50%"],
                body: [
                  [
                    { text: metadata.data.impactedVersion },
                    { text: metadata.data.fixedVersion }
                  ],
                  [impactedVersion, fixedVersion]
                ]
              },
              layout: {
                hLineColor: "gray",
                vLineColor: "gray"
              }
            };
            details.push([packageName, version]);
          });
          if (originalPackageCount > 3 && !isFullList) {
            details.push([
              { text: `...... (${originalPackageCount} Packages)` }
            ]);
          }
          return details;
        };

        const _getRowData2 = function(item, id, metadata) {
          let name = item.name;
          let description = item.description;
          let score = _getScore(item, metadata);
          let _package = _getPackage(item, metadata);
          let publishedTime = item.published_datetime;

          return [name, description, score, _package, publishedTime];
        };

        const getTitleText = function(isFiltered) {
          if (isFiltered) {
            return "Filtered Vulnerabilities Report (Assets View)";
          } else {
            return "Full Vulnerabilities Report (Assets View)";
          }
        };

        const preparePackagesWith3Columns = function(item, metaData) {
          let packagesMatrix = [];
          let rowData = [];
          let packageGrids = _getPackage(item, metaData, true);
          for (let i = 0; i < packageGrids.length; i++) {
            if (i % 3 === 0) {
              if (Math.floor(i / 3) > 0)
                packagesMatrix.push({
                  columns: JSON.parse(JSON.stringify(rowData))
                });
              rowData = [{}, {}, {}];
            }
            rowData[i % 3] = packageGrids[i];
          }
          packagesMatrix.push({ columns: JSON.parse(JSON.stringify(rowData)) });
          return packagesMatrix;
        };

        const prepareAppendix = function(docData) {
          console.log("docData.data: ", JSON.parse(JSON.stringify(docData)));
          let appendix4Packages = [];
          docData.data.vulnerabilities.forEach(item => {
            let cve = {
              text: item.name,
              style: "appendixTitle"
            };

            let packagesRaw = Object.entries(item.Packages);
            let packageCount = packagesRaw.length;
            let packages = preparePackagesWith3Columns(item, docData.metadata);
            let lineBreak = {
              text: "\n\n"
            };
            appendix4Packages.push(cve);
            if (packageCount > 0) {
              appendix4Packages.push(packages);
            }
            appendix4Packages.push(lineBreak);
          });
          return {
            appendix4Packages
          };
        };

        const _formatContent2 = function(docData) {
          let metadata = docData.metadata;
          let images = docData.images;
          let charts = docData.charts;
          let titleText = getTitleText(docData.data.isAdvFilterOn);

          let docDefinition = {
            info: {
              title: metadata.title,
              author: "NeuVector",
              subject: "Vulnerability report (Service View)",
              keywords:
                "vulnerability report service group pods container workload host node platform image"
            },
            headerData: {
              text: metadata.others.headerText,
              alignment: "center",
              italics: true,
              style: "pageHeader"
            },
            footerData: {
              line: {
                image: images.FOOTER_LINE,
                width: 650,
                height: 1,
                margin: [50, 5, 0, 10]
              },
              text: metadata.others.footerText
            },
            header: function(currentPage) {
              if (currentPage === 2 || currentPage === 3) {
                return {
                  text: metadata.others.headerText,
                  alignment: "center",
                  italics: true,
                  style: "pageHeader"
                };
              }
            },
            footer: function(currentPage) {
              if (currentPage > 1) {
                return {
                  stack: [
                    {
                      image: images.FOOTER_LINE,
                      width: 650,
                      height: 1,
                      margin: [50, 5, 0, 10]
                    },
                    {
                      text: [
                        { text: metadata.others.footerText, italics: true },
                        { text: " |   " + currentPage }
                      ],
                      alignment: "right",
                      style: "pageFooter"
                    }
                  ]
                };
              }
            },
            pageSize: "LETTER",
            pageOrientation: "landscape",
            pageMargins: [50, 50, 50, 45],
            defaultStyle: {
              fontSize: 7,
              columnGap: 10
            },
            content: [
              {
                image: images.BACKGROUND,
                width: 1000,
                absolutePosition: { x: 0, y: 300 }
              },
              {
                image: images.ABSTRACT,
                width: 450
              },
              {
                image: images[metadata.others.logoName],
                width: 400,
                absolutePosition: { x: 350, y: 180 }
              },
              {
                text: metadata.title2,
                fontSize: 34,
                color: "#777",
                bold: true,
                absolutePosition: { x: 150, y: 450 },
                pageBreak: "after"
              },
              {
                toc: {
                  title: {
                    text: titleText,
                    style: "tocTitle"
                  },
                  numberStyle: "tocNumber"
                },
                margin: [60, 35, 20, 60],
                pageBreak: "after"
              },
              {
                text: [
                  {
                    text: metadata.others.subTitleDetails,
                    style: "contentHeader",
                    tocItem: true,
                    tocStyle: {
                      fontSize: 16,
                      bold: true,
                      color: "#4863A0",
                      margin: [80, 15, 0, 60]
                    }
                  },
                  {
                    text: "    (Please refer appendix for details of CVEs)",
                    color: "#4863A0",
                    fontSize: 10
                  }
                ]
              },
              {
                text: "Containers",
                color: "#4863A0",
                fontSize: 10
              },
              {
                style: "tableExample",
                table: {
                  headerRows: 1,
                  dontBreakRows: false,
                  widths: ["15%", "10%", "12%", "7%", "10%", "8%", "32%", "6%"],
                  body: [
                    [
                      { text: metadata.wlHeader.name, style: "tableHeader" },
                      { text: metadata.wlHeader.domain, style: "tableHeader" },
                      { text: metadata.wlHeader.apps, style: "tableHeader" },
                      {
                        text: metadata.wlHeader.policyMode,
                        style: "tableHeader"
                      },
                      { text: metadata.wlHeader.group, style: "tableHeader" },
                      { text: metadata.header.vulsCnt, style: "tableHeader" },
                      { text: metadata.header.vuls, style: "tableHeader" },
                      {
                        text: metadata.wlHeader.scanned_at,
                        style: "tableHeader"
                      }
                    ]
                  ]
                },
                pageBreak: "after"
              },
              {
                text: [
                  {
                    text: "Hosts",
                    color: "#4863A0",
                    fontSize: 10
                  }
                ]
              },
              {
                style: "tableExample",
                table: {
                  headerRows: 1,
                  dontBreakRows: false,
                  widths: [
                    "11%",
                    "6%",
                    "10%",
                    "6%",
                    "7%",
                    "10%",
                    "10%",
                    "8%",
                    "24%",
                    "8%"
                  ],
                  body: [
                    [
                      { text: metadata.htHeader.name, style: "tableHeader" },
                      { text: metadata.htHeader.os, style: "tableHeader" },
                      { text: metadata.htHeader.kernel, style: "tableHeader" },
                      { text: metadata.htHeader.cpus, style: "tableHeader" },
                      { text: metadata.htHeader.memory, style: "tableHeader" },
                      {
                        text: metadata.htHeader.containers,
                        style: "tableHeader"
                      },
                      {
                        text: metadata.htHeader.policyMode,
                        style: "tableHeader"
                      },
                      { text: metadata.header.vulsCnt, style: "tableHeader" },
                      { text: metadata.header.vuls, style: "tableHeader" },
                      {
                        text: metadata.wlHeader.scanned_at,
                        style: "tableHeader"
                      }
                    ]
                  ]
                },
                pageBreak: "after"
              },
              {
                text: [
                  {
                    text: "Platforms",
                    color: "#4863A0",
                    fontSize: 10
                  }
                ]
              },
              {
                style: "tableExample",
                table: {
                  headerRows: 1,
                  dontBreakRows: false,
                  widths: ["10%", "10%", "10%", "10%", "60%"],
                  body: [
                    [
                      { text: metadata.pfHeader.name, style: "tableHeader" },
                      { text: metadata.pfHeader.version, style: "tableHeader" },
                      { text: metadata.pfHeader.baseOs, style: "tableHeader" },
                      { text: metadata.header.vulsCnt, style: "tableHeader" },
                      { text: metadata.header.vuls, style: "tableHeader" }
                    ]
                  ]
                },
                pageBreak: "after"
              },
              {
                text: [
                  {
                    text: "Images",
                    color: "#4863A0",
                    fontSize: 10
                  }
                ]
              },
              {
                style: "tableExample",
                table: {
                  headerRows: 1,
                  dontBreakRows: false,
                  widths: ["20%", "10%", "70%"],
                  body: [
                    [
                      { text: metadata.mgHeader.name, style: "tableHeader" },
                      { text: metadata.header.vulsCnt, style: "tableHeader" },
                      { text: metadata.header.vuls, style: "tableHeader" }
                    ]
                  ]
                },
                pageBreak: "after"
              },
              {
                text: [
                  {
                    text: metadata.others.appendixText2,
                    style: "contentHeader",
                    tocItem: true,
                    tocStyle: {
                      fontSize: 16,
                      bold: true,
                      color: "#4863A0",
                      margin: [80, 15, 0, 60]
                    }
                  },
                  {
                    text: `    (${metadata.others.appendixDesc2})`,
                    color: "#3090C7",
                    fontSize: 10
                  }
                ]
              },
              {
                text: "\n\n"
              },
              {
                style: "tableExample",
                table: {
                  headerRows: 1,
                  dontBreakRows: false,
                  widths: ["15%", "30%", "8%", "30%", "17%"],
                  body: [
                    [
                      { text: metadata.header.name, style: "tableHeader" },
                      { text: metadata.header.desc, style: "tableHeader" },
                      { text: metadata.header.score, style: "tableHeader" },
                      { text: metadata.header.package, style: "tableHeader" },
                      {
                        text: metadata.header.publishedTime,
                        style: "tableHeader"
                      }
                    ]
                  ]
                }
              },
              {
                text: [
                  {
                    text: metadata.others.appendixPackagesText,
                    style: "contentHeader",
                    tocItem: true,
                    tocStyle: {
                      fontSize: 16,
                      bold: true,
                      color: "#4863A0",
                      margin: [80, 15, 0, 60]
                    }
                  },
                  {
                    text: `    (${metadata.others.appendixPackagesDesc})`,
                    color: "#3090C7",
                    fontSize: 10
                  }
                ],
                pageBreak: "before"
              },
              {}
            ],
            styles: {
              pageHeader: {
                fontSize: 14,
                italic: true,
                bold: true,
                color: "grey",
                margin: [0, 10, 5, 5]
              },
              pageFooter: {
                fontSize: 12,
                color: "grey",
                margin: [0, 5, 55, 5]
              },
              pageFooterImage: {
                width: 750,
                height: 1,
                margin: [50, 5, 10, 10]
              },
              tocTitle: {
                fontSize: 22,
                color: "#566D7E",
                lineHeight: 2
              },
              tocNumber: {
                italics: true,
                fontSize: 15
              },
              tableHeader: {
                bold: true,
                fontSize: 10,
                alignment: "center"
              },
              contentHeader: {
                fontSize: 16,
                bold: true,
                color: "#3090C7",
                margin: [0, 10, 0, 10]
              },
              contentSubHeader: {
                fontSize: 14,
                bold: true,
                color: "black",
                margin: [0, 10, 0, 10]
              },
              content: {
                fontSize: 10,
                margin: [5, 5, 5, 5]
              },
              title: {
                bold: true,
                fontSize: 8
              },
              subTitle: {
                bold: true,
                fontSize: 7
              },
              appendixTitle: {
                fontSize: 10,
                bold: true,
                margin: [0, 2, 0, 2]
              },
              appendixText: {
                fontSize: 8,
                margin: [0, 2, 0, 2]
              },
              danger: {
                bold: true,
                color: "#dc4034",
                fontSize: 8
              },
              warning: {
                bold: true,
                color: "#ff9800",
                fontSize: 8
              },
              info: {
                bold: true,
                color: "#2196f3",
                fontSize: 8
              },
              discover: {
                bold: true,
                color: "#2196f3",
                fontSize: 8
              },
              monitor: {
                bold: true,
                color: "#4e39c1",
                fontSize: 8
              },
              protect: {
                bold: true,
                color: "#64a150",
                fontSize: 8
              },
              success: {
                bold: true,
                color: "#64a150",
                fontSize: 8
              },
              error: {
                bold: true,
                color: "#e91e63",
                fontSize: 8
              }
            }
          };

          let detailGrids = prepareDetails(
            docData.data.masterData,
            docData.data.vulnerabilities,
            docData.data.isFiltered,
            docData.data.advFilter
          );

          const _getPlatformVerssion = function(name, kubeVersion, ocVersion) {
            if (name.toLowerCase().includes(metadata.others.KUBE)) {
              if (name.toLowerCase().includes(metadata.others.OC)) {
                return ocVersion;
              } else {
                return kubeVersion;
              }
            } else {
              return "";
            }
          };

          const _getVuls = function(vuls) {
            return JSON.parse(
              `{"text":[${vuls
                .slice(0, 350)
                .map(vul => {
                  return JSON.stringify(vul);
                })
                .join(',{"text": ", "},')}${
                vuls.length > 350
                  ? `,{"text": "......(Total: ${vuls.length})"}`
                  : ""
              }]}`
            );
          };

          const _getHiMed = function(high, medium) {
            return high + medium > 0
              ? {
                  text: [
                    { text: high.toString(), style: "danger" },
                    { text: "/" },
                    { text: medium.toString(), style: "warning" }
                  ]
                }
              : { text: "No Vulnerabilities", style: "success" };
          };

          const _getRowData4Workloads = function(item) {
            let name = item.pod_name;
            let domain = item.domain;
            let apps = item.applications.join(", ");
            let policyMode = {
              text: item.policy_mode,
              style: item.policy_mode.toLowerCase()
            };
            let group = `${item.service_group}`;
            let hiMed = _getHiMed(item.high, item.medium);
            let vuls = _getVuls(item.vulnerabilites);
            let scanned_at = item.scanned_at;

            return [
              name,
              domain,
              apps,
              policyMode,
              group,
              hiMed,
              vuls,
              scanned_at
            ];
          };

          const _getRowData4Hosts = function(item) {
            let name = item.name;
            let os = item.os;
            let kernel = item.kernel;
            let cpus = item.cpus;
            let memory = item.memory;
            let containers = item.containers;
            let policyMode = {
              text: item.policy_mode,
              style: item.policy_mode.toLowerCase()
            };
            let hiMed = _getHiMed(item.high, item.medium);
            let vuls = _getVuls(item.vulnerabilites);
            let scanned_at = item.scanned_at;

            return [
              name,
              os,
              kernel,
              cpus,
              memory,
              containers,
              policyMode,
              hiMed,
              vuls,
              scanned_at
            ];
          };

          const _getRowData4Platforms = function(item) {
            let name = item.platform;
            let version = _getPlatformVerssion(
              item.platform,
              item.kube_version,
              item.openshift_version
            );
            let baseOs = item.base_os;
            let hiMed = _getHiMed(item.high, item.medium);
            let vuls = _getVuls(item.vulnerabilites);

            return [name, version, baseOs, hiMed, vuls];
          };

          const _getRowData4Images = function(item) {
            let name = item.image_name;
            let hiMed = _getHiMed(item.high, item.medium);
            let vuls = _getVuls(item.vulnerabilites);

            return [name, hiMed, vuls];
          };

          detailGrids[0].sort((a, b) => {
            return b.high + b.medium - (a.high + a.medium);
          });

          detailGrids[1].sort((a, b) => {
            return b.high + b.medium - (a.high + a.medium);
          });

          detailGrids[2].sort((a, b) => {
            return b.high + b.medium - (a.high + a.medium);
          });

          detailGrids[3].sort((a, b) => {
            return b.high + b.medium - (a.high + a.medium);
          });

          if (detailGrids[0].length > 0) {
            let compliantWorkloads = 0;
            for (let item of detailGrids[0]) {
              compliantWorkloads += item.evaluation === 0 ? 1 : 0;
              docDefinition.content[7].table.body.push(
                _getRowData4Workloads(item)
              );
            }
            docDefinition.content[6].text = `${
              docDefinition.content[6].text
            } (Compliant Workloads (No vulnerabilities): ${Math.round(
              (compliantWorkloads / detailGrids[0].length) * 100
            )}% (${compliantWorkloads} Workload(s)))`;
          } else {
            docDefinition.content[6] = {};
            docDefinition.content[7] = {};
          }

          if (detailGrids[1].length > 0) {
            let compliantHosts = 0;
            for (let item of detailGrids[1]) {
              compliantHosts += item.evaluation === 0 ? 1 : 0;
              docDefinition.content[9].table.body.push(_getRowData4Hosts(item));
            }
            docDefinition.content[8].text[0].text = `${
              docDefinition.content[8].text[0].text
            } (Compliant Hosts (No vulnerabilities): ${Math.round(
              (compliantHosts / detailGrids[1].length) * 100
            )}% (${compliantHosts} Host(s)))`;
          } else {
            docDefinition.content[8] = {};
            docDefinition.content[9] = {};
          }

          if (detailGrids[2].length > 0) {
            for (let item of detailGrids[2]) {
              docDefinition.content[11].table.body.push(
                _getRowData4Platforms(item)
              );
            }
          } else {
            docDefinition.content[10] = {};
            docDefinition.content[11] = {};
          }

          if (detailGrids[3].length > 0) {
            let compliantImages = 0;
            for (let item of detailGrids[3]) {
              compliantImages += item.evaluation === 0 ? 1 : 0;
              docDefinition.content[13].table.body.push(
                _getRowData4Images(item)
              );
            }
            docDefinition.content[12].text[0].text = `${
              docDefinition.content[12].text[0].text
            } (Compliant Images (No vulnerabilities): ${Math.round(
              (compliantImages / detailGrids[3].length) * 100
            )}% (${compliantImages} Image(s)))`;
          } else {
            docDefinition.content[12] = {};
            docDefinition.content[13] = {};
          }

          let index4Appendix = 1;
          for (let item of docData.data.vulnerabilities) {
            docDefinition.content[16].table.body.push(
              _getRowData2(item, index4Appendix, metadata)
            );
            index4Appendix++;
          }

          docDefinition.content[18] = prepareAppendix(
            docData
          ).appendix4Packages;

          console.log("docDefinition: ", docDefinition);

          return docDefinition;
        };

        let dateStart = new Date();
        console.log("Worker2 is starting...", dateStart.toTimeString());
        const showProgress = (function(self) {
          return function(progress) {
            if (Math.floor(progress * 100000) % 1000 === 0) {
              self.postMessage({ progress: progress });
            }
          };
        })(self);
        self.onmessage = event => {
          let docDefinition = _formatContent2(JSON.parse(event.data));

          docDefinition.header = function(currentPage) {
            if (currentPage === 2 || currentPage === 3) {
              return docDefinition.headerData;
            }
          };

          docDefinition.footer = function(currentPage) {
            if (currentPage > 1) {
              return {
                stack: [
                  docDefinition.footerData.line,
                  {
                    text: [
                      { text: docDefinition.footerData.text, italics: true },
                      { text: " |   " + currentPage }
                    ],
                    alignment: "right",
                    style: "pageFooter"
                  }
                ]
              };
            }
          };

          const drawReportInWebWorker2 = function(docDefinition) {
            let baseURL = event.srcElement.origin;
            self.importScripts(
              baseURL + "/vendor/pdfmake/build/pdfmake.js",
              baseURL + "/vendor/pdfmake/build/vfs_fonts.js"
            );

            let report = pdfMake.createPdf(docDefinition);

            report.getBlob(
              function(blob) {
                let dateEnd = new Date();
                console.log("Worker2 is end...", dateEnd.toTimeString());
                self.postMessage({ blob: blob, progress: 1 });
                self.close();
              },
              { progressCallback: showProgress }
            );
          };
          drawReportInWebWorker2(docDefinition);
        };
        return _formatContent2;
      };

      const sendServiceViewData2Worker = function(
        masterData,
        vulnerabilities,
        isFiltered,
        advFilter
      ) {
        $scope.pdfBlob2 = null;
        if ($scope.worker2) {
          $scope.worker2.terminate();
          console.info("killed an existing running worker2...");
        }
        $scope.worker2 = run(_webWorkerJob2);
        if ($scope.worker2) {
          let docData = Object.assign(
            {},
            {
              data: {
                masterData: masterData,
                vulnerabilities: vulnerabilities.map(vul => {
                  vul.published_datetime = $filter("date")(
                    vul.published_timestamp * 1000,
                    "MMM dd, y HH:mm:ss"
                  );
                  return vul;
                }),
                isFiltered: isFiltered,
                advFilter: advFilter,
                isAdvFilterOn: $scope.isAdvFilterOn()
              }
            },
            { images: imageMap }, //Picture URI code which is used in PDF
            {
              metadata: _getI18NMessages({
                filteredCount: vulnerabilities.length,
                rangedCount: $scope.count4Pdf
              })
            }
          );
          console.log("Post message to worker2...");
          $scope.worker2.postMessage(JSON.stringify(docData));
          $scope.worker2.onmessage = event => {
            $scope.pdfBlob2 = event.data.blob;
            $scope.progress2 = Math.floor(event.data.progress * 100);
            $scope.$apply();
          };
        } else {
          $scope.progress2 = 100;
        }
      };

      const drawReport2 = function(docDefinition) {
        let report = pdfMake.createPdf(docDefinition);

        report.getBlob(function(blob) {
          $scope.isPdfPreparing2 = false;
          FileSaver.saveAs(
            blob,
            `${$translate.instant(
              "scan.report.TITLE2"
            )}_${Utils.parseDatetimeStr(new Date())}.pdf`
          );
        });
      };

      $scope.downloadPdf2 = function() {
        let masterData = {
          workloadMap4Pdf: $scope.workloadMap4Pdf,
          hostMap4Pdf: $scope.hostMap4Pdf,
          platformMap4Pdf: $scope.platformMap4Pdf,
          imageMap4Pdf: $scope.imageMap4Pdf
        };
        let vulnerabilities = $scope.vulnerabilities4Pdf;
        let isFiltered = false;
        let filteredItems = {};
        if (
          $scope.advFilter.containerName ||
          $scope.advFilter.nodeName ||
          $scope.advFilter.imageName
        ) {
          isFiltered = true;
        }
        $scope.isPdfPreparing2 = true;
        let docData = Object.assign(
          {},
          {
            data: {
              masterData: masterData,
              vulnerabilities: vulnerabilities.map(vul => {
                vul.published_datetime = $filter("date")(
                  vul.published_timestamp * 1000,
                  "MMM dd, y HH:mm:ss"
                );
                return vul;
              }),
              isFiltered: isFiltered,
              advFilter: $scope.advFilter,
              isAdvFilterOn: $scope.isAdvFilterOn()
            }
          },
          { images: imageMap }, //Picture URI code which is used in PDF
          {
            metadata: _getI18NMessages({
              filteredCount: vulnerabilities.length,
              rangedCount: $scope.count4Pdf
            })
          }
        );
        if ($scope.worker2) {
          $interval.cancel(timer2);
          timer2 = $interval(function() {
            if ($scope.pdfBlob2) {
              $scope.isPdfPreparing2 = false;
              FileSaver.saveAs(
                $scope.pdfBlob2,
                `${$translate.instant(
                  "scan.report.TITLE2"
                )}_${Utils.parseDatetimeStr(new Date())}.pdf`
              );
              $interval.cancel(timer2);
            }
          }, 1000);
        } else {
          let docDefinition = _webWorkerJob2()(docData);
          drawReport2(docDefinition);
        }
      };

      /*==============================================================================
      PDF(CVE View) code start
      ================================================================================*/

      const getChartsForPDF = function() {
        let topImpactfulVulnerabilies = document
          .getElementById("bar12PDF")
          .toDataURL();
        let topVulnerableImages = document
          .getElementById("bar22PDF")
          .toDataURL();

        return {
          canvas: {
            topImpactfulVulnerabilies,
            topVulnerableImages
          }
        };
      };

      $scope.downloadPdf = function() {
        $scope.isPdfPreparing = true;
        let vulnerabilities4Pdf = $scope.vulnerabilities.map(vulnerability => {
          vulnerability.workloads = vulnerability.workloads.filter(workload =>
            $scope.namespaceFilter(workload)
          );
          return vulnerability;
        });
        let docData = Object.assign(
          {},
          {
            data:
              vulnerabilities4Pdf.length >= $scope.REPORT_TABLE_ROW_LIMIT
                ? vulnerabilities4Pdf.slice(0, $scope.REPORT_TABLE_ROW_LIMIT)
                : vulnerabilities4Pdf
          },
          {
            metadata: _getI18NMessages({
              filteredCount: $scope.vulnerabilities.length,
              rangedCount: $scope.count4Pdf
            })
          },
          { images: imageMap }, //Picture URI code which is used in PDF
          { charts: getChartsForPDF() },
          { distByLevel: $scope.distByLevel },
          { distByName: $scope.distByName },
          { rowLimit: $scope.REPORT_TABLE_ROW_LIMIT }
        );
        if ($scope.worker) {
          $interval.cancel(timer);
          timer = $interval(function() {
            if ($scope.pdfBlob) {
              $scope.isPdfPreparing = false;
              FileSaver.saveAs(
                $scope.pdfBlob,
                `${$translate.instant(
                  "scan.report.TITLE"
                )}_${Utils.parseDatetimeStr(new Date())}.pdf`
              );
              $interval.cancel(timer);
            }
          }, 1000);
        } else {
          let docDefinition = _formatContent(docData);
          drawReport(docDefinition);
        }
      };
      const prepareNamesWith3Columns = function(names, type) {
        let namesMatrix = [];
        let rowData = [];
        for (let i = 0; i < names.length; i++) {
          if (i % 3 === 0) {
            if (Math.floor(i / 3) > 0)
              namesMatrix.push({ columns: angular.copy(rowData) });
            rowData = [{ text: "" }, { text: "" }, { text: "" }];
          }
          rowData[i % 3] = {
            text: names[i].display_name,
            color: PDF_TEXT_COLOR[type.toUpperCase()],
            style: "appendixText"
          };
        }
        namesMatrix.push({ columns: angular.copy(rowData) });
        return namesMatrix;
      };

      const preparePackagesWith3Columns = function(item, metaData) {
        let packagesMatrix = [];
        let rowData = [];
        let packageGrids = _getPackage(item, metaData, true);
        for (let i = 0; i < packageGrids.length; i++) {
          if (i % 3 === 0) {
            if (Math.floor(i / 3) > 0)
              packagesMatrix.push({ columns: angular.copy(rowData) });
            rowData = [{}, {}, {}];
          }
          rowData[i % 3] = packageGrids[i];
        }
        packagesMatrix.push({ columns: angular.copy(rowData) });
        return packagesMatrix;
      };

      const prepareAppendix = function(docData, metaData) {
        let appendix = [];
        let appendix4Packages = [];
        console.log("docData.data: ", docData.data);
        docData.data.forEach(item => {
          let cve = {
            text: item.name,
            style: "appendixTitle"
          };
          let image = {
            text: `${docData.metadata.data.images}: ${item.images.length}`,
            color: PDF_TEXT_COLOR.IMAGE,
            style: "appendixTitle"
          };
          let imageList = prepareNamesWith3Columns(item.images, "image");
          let container = {
            text: `${docData.metadata.data.containers}: ${item.workloads.length}`,
            color: PDF_TEXT_COLOR.CONTAINER,
            style: "appendixTitle"
          };
          let containerList = prepareNamesWith3Columns(
            item.workloads,
            "container"
          );
          let node = {
            text: `${docData.metadata.data.nodes}: ${item.nodes.length}`,
            color: PDF_TEXT_COLOR.NODE,
            style: "appendixTitle"
          };
          let nodeList = prepareNamesWith3Columns(item.nodes, "node");
          let platform = {
            text: `${docData.metadata.data.platforms}: ${item.platforms.length}`,
            color: PDF_TEXT_COLOR.PLATFORM,
            style: "appendixTitle"
          };
          let platformList = prepareNamesWith3Columns(
            item.platforms,
            "platform"
          );

          let packagesRaw = Object.entries(item.Packages);
          let packageCount = packagesRaw.length;
          let packages = preparePackagesWith3Columns(item, metaData);
          let lineBreak = {
            text: "\n\n"
          };
          appendix.push(cve);
          appendix4Packages.push(cve);
          if (item.images.length > 0) {
            appendix.push(image);
            appendix = appendix.concat(imageList);
          }
          if (item.workloads.length > 0) {
            appendix.push(container);
            appendix = appendix.concat(containerList);
          }
          if (item.nodes.length > 0) {
            appendix.push(node);
            appendix = appendix.concat(nodeList);
          }
          if (item.platforms.length > 0) {
            appendix.push(platform);
            appendix = appendix.concat(platformList);
          }
          if (packageCount > 0) {
            appendix4Packages.push(packages);
          }
          appendix.push(lineBreak);
          appendix4Packages.push(lineBreak);
        });
        console.log("appendix: ", appendix, appendix4Packages);
        return {
          appendix,
          appendix4Packages
        };
      };

      const _formatContent = function(docData) {
        let metadata = docData.metadata;
        let images = docData.images;
        let charts = docData.charts;

        let docDefinition = {
          info: {
            title: metadata.title,
            author: "NeuVector",
            subject: "Vulnerability report",
            keywords: "Vulnerability report"
          },
          headerData: {
            text: metadata.others.headerText,
            alignment: "center",
            italics: true,
            style: "pageHeader"
          },
          footerData: {
            line: {
              image: images.FOOTER_LINE,
              width: 650,
              height: 1,
              margin: [50, 5, 0, 10]
            },
            text: metadata.others.footerText
          },
          header: function(currentPage) {
            if (currentPage === 2 || currentPage === 3) {
              return {
                text: metadata.others.headerText,
                alignment: "center",
                italics: true,
                style: "pageHeader"
              };
            }
          },
          footer: function(currentPage) {
            if (currentPage > 1) {
              return {
                stack: [
                  {
                    image: images.FOOTER_LINE,
                    width: 650,
                    height: 1,
                    margin: [50, 5, 0, 10]
                  },
                  {
                    text: [
                      { text: metadata.others.footerText, italics: true },
                      { text: " |   " + currentPage }
                    ],
                    alignment: "right",
                    style: "pageFooter"
                  }
                ]
              };
            }
          },
          pageSize: "LETTER",
          pageOrientation: "landscape",
          pageMargins: [50, 50, 50, 45],
          defaultStyle: {
            fontSize: 7,
            columnGap: 10
          },
          content: [
            {
              image: images.BACKGROUND,
              width: 1000,
              absolutePosition: { x: 0, y: 300 }
            },
            {
              image: images.ABSTRACT,
              width: 450
            },
            {
              image: images[metadata.others.logoName],
              width: 400,
              absolutePosition: { x: 350, y: 180 }
            },
            {
              text: metadata.title,
              fontSize: 40,
              color: "#777",
              bold: true,
              absolutePosition: { x: 150, y: 450 },
              pageBreak: "after"
            },

            {
              toc: {
                title: {
                  text: " In this vulnerability Report",
                  style: "tocTitle"
                },
                numberStyle: "tocNumber"
              },
              margin: [60, 35, 20, 60],
              pageBreak: "after"
            },

            {
              text: [
                {
                  text: metadata.others.reportSummary,
                  style: "contentHeader",
                  tocItem: true,
                  tocStyle: {
                    fontSize: 16,
                    bold: true,
                    color: "#4863A0",
                    margin: [80, 15, 0, 60]
                  }
                },
                {
                  text: `    ${metadata.others.summaryRange}`,
                  color: "#3090C7",
                  fontSize: 10
                }
              ]
            },

            {
              text: metadata.others.topImpactfulVulnerabilities,
              style: "contentSubHeader",
              tocItem: true,
              tocStyle: {
                fontSize: 12,
                italic: true,
                color: "black",
                margin: [95, 10, 0, 60]
              }
            },

            {
              columns: [
                {
                  image: charts.canvas.topImpactfulVulnerabilies,
                  width: 700
                }
              ]
            },

            {
              text: metadata.others.topVulnerableImages,
              style: "contentSubHeader",
              tocItem: true,
              tocStyle: {
                fontSize: 12,
                italic: true,
                color: "black",
                margin: [95, 10, 0, 60]
              }
            },

            {
              columns: [
                {
                  image: charts.canvas.topVulnerableImages,
                  width: 700
                }
              ],

              pageBreak: "after"
            },

            {
              text: [
                {
                  text: metadata.others.subTitleDetails,
                  style: "contentHeader",
                  tocItem: true,
                  tocStyle: {
                    fontSize: 16,
                    bold: true,
                    color: "#4863A0",
                    margin: [80, 15, 0, 60]
                  }
                },
                {
                  text: `    ${metadata.others.detailsLimit}`,
                  color: "#fe6e6b",
                  fontSize: 10
                }
              ]
            },

            {
              style: "tableExample",
              table: {
                headerRows: 1,
                dontBreakRows: false,
                widths: ["10%", "25%", "6%", "27%", "12%", "20%"],
                body: [
                  [
                    { text: metadata.header.name, style: "tableHeader" },
                    { text: metadata.header.desc, style: "tableHeader" },
                    { text: metadata.header.score, style: "tableHeader" },
                    { text: metadata.header.package, style: "tableHeader" },
                    {
                      text: metadata.header.publishedTime,
                      style: "tableHeader"
                    },
                    { text: metadata.header.impact, style: "tableHeader" }
                  ]
                ]
              },
              pageBreak: "after"
            },
            {
              text: [
                {
                  text: metadata.others.appendixText,
                  style: "contentHeader",
                  tocItem: true,
                  tocStyle: {
                    fontSize: 16,
                    bold: true,
                    color: "#4863A0",
                    margin: [80, 15, 0, 60]
                  }
                },
                {
                  text: `    (${metadata.others.appendixDesc})`,
                  color: "#3090C7",
                  fontSize: 10
                }
              ]
            },
            {},
            {
              text: [
                {
                  text: metadata.others.appendixPackagesText,
                  style: "contentHeader",
                  tocItem: true,
                  tocStyle: {
                    fontSize: 16,
                    bold: true,
                    color: "#4863A0",
                    margin: [80, 15, 0, 60]
                  }
                },
                {
                  text: `    (${metadata.others.appendixPackagesDesc})`,
                  color: "#3090C7",
                  fontSize: 10
                }
              ],
              pageBreak: "before"
            },
            {},
            {
              text: "\n\n"
            }
          ],
          styles: {
            pageHeader: {
              fontSize: 14,
              italic: true,
              bold: true,
              color: "grey",
              margin: [0, 10, 5, 5]
            },
            pageFooter: {
              fontSize: 12,
              color: "grey",
              margin: [0, 5, 55, 5]
            },
            pageFooterImage: {
              width: 750,
              height: 1,
              margin: [50, 5, 10, 10]
            },
            tocTitle: {
              fontSize: 22,
              color: "#566D7E",
              lineHeight: 2
            },
            tocNumber: {
              italics: true,
              fontSize: 15
            },
            tableHeader: {
              bold: true,
              fontSize: 10,
              alignment: "center"
            },
            contentHeader: {
              fontSize: 16,
              bold: true,
              color: "#3090C7",
              margin: [0, 10, 0, 10]
            },
            contentSubHeader: {
              fontSize: 14,
              bold: true,
              color: "black",
              margin: [0, 10, 0, 10]
            },
            content: {
              fontSize: 10,
              margin: [5, 5, 5, 5]
            },
            title: {
              bold: true,
              fontSize: 8
            },
            subTitle: {
              bold: true,
              fontSize: 7
            },
            appendixTitle: {
              fontSize: 10,
              bold: true,
              margin: [0, 2, 0, 2]
            },
            appendixText: {
              fontSize: 8,
              margin: [0, 2, 0, 2]
            },
            danger: {
              bold: true,
              color: "#dc4034",
              fontSize: 8
            },
            warning: {
              bold: true,
              color: "#ff9800",
              fontSize: 8
            },
            info: {
              bold: true,
              color: "#2196f3",
              fontSize: 8
            },
            error: {
              bold: true,
              color: "#e91e63",
              fontSize: 8
            }
          }
        };

        let index = 1;

        for (let item of docData.data) {
          docDefinition.content[11].table.body.push(
            _getRowData(item, index, metadata)
          );
          index++;
        }
        let appendix = prepareAppendix(docData, metadata);
        docDefinition.content[13] = appendix.appendix;
        docDefinition.content[15] = appendix.appendix4Packages;
        console.log("docDefinition", docDefinition);

        return docDefinition;
      };

      const drawReport = function(docDefinition) {
        let report = pdfMake.createPdf(docDefinition);

        report.getBlob(function(blob) {
          $scope.isPdfPreparing = false;
          FileSaver.saveAs(
            blob,
            `${$translate.instant(
              "scan.report.TITLE"
            )}_${Utils.parseDatetimeStr(new Date())}.pdf`
          );
        });
      };

      const _getI18NMessages = function(options) {
        return {
          title: $translate.instant("scan.report.TITLE", {}, "", "en"),
          title2: $translate.instant("scan.report.TITLE2", {}, "", "en"),
          wlHeader: {
            name: $translate.instant("containers.detail.NAME", {}, "", "en"),
            domain: $translate.instant("audit.gridHeader.DOMAIN", {}, "", "en"),
            apps: $translate.instant(
              "containers.detail.APPLICATIONS",
              {},
              "",
              "en"
            ),
            policyMode: $translate.instant(
              "containers.detail.POLICY_MODE",
              {},
              "",
              "en"
            ),
            group: $translate.instant("group.GROUP", {}, "", "en"),
            scanned_at: $translate.instant("scan.gridHeader.TIME", {}, "", "en")
          },
          htHeader: {
            name: $translate.instant("nodes.detail.NAME", {}, "", "en"),
            os: $translate.instant("nodes.detail.OS", {}, "", "en"),
            kernel: $translate.instant(
              "nodes.detail.KERNEL_VERSION",
              {},
              "",
              "en"
            ),
            cpus: $translate.instant("nodes.detail.NUM_OF_CPUS", {}, "", "en"),
            memory: $translate.instant("nodes.detail.MEMORY", {}, "", "en"),
            containers: $translate.instant(
              "nodes.detail.NUM_OF_CONTAINERS",
              {},
              "",
              "en"
            ),
            policyMode: $translate.instant(
              "containers.detail.POLICY_MODE",
              {},
              "",
              "en"
            ),
            scanned_at: $translate.instant("scan.gridHeader.TIME", {}, "", "en")
          },
          pfHeader: {
            name: $translate.instant("nodes.detail.NAME", {}, "", "en"),
            version: $translate.instant(
              "scan.gridHeader.VERSION",
              {},
              "",
              "en"
            ),
            baseOs: $translate.instant("audit.gridHeader.BASE_OS", {}, "", "en")
          },
          mgHeader: {
            name: $translate.instant("nodes.detail.NAME", {}, "", "en")
          },
          header: {
            vulsCnt: $translate.instant(
              "scan.report.gridHeader.HI_MED",
              {},
              "",
              "en"
            ),
            vuls: $translate.instant(
              "group.gridHeader.VULNERABILITIES",
              {},
              "",
              "en"
            ),
            name: $translate.instant(
              "scan.report.gridHeader.NAME",
              {},
              "",
              "en"
            ),
            score: $translate.instant(
              "scan.report.gridHeader.SCORE",
              {},
              "",
              "en"
            ),
            package: $translate.instant(
              "scan.report.gridHeader.PACKAGES",
              {},
              "",
              "en"
            ),
            publishedTime: $translate.instant(
              "scan.gridHeader.PUBLISHED_TIME",
              {},
              "",
              "en"
            ),
            desc: $translate.instant(
              "scan.report.gridHeader.DESC",
              {},
              "",
              "en"
            ),
            impact: $translate.instant(
              "scan.report.gridHeader.IMPACT",
              {},
              "",
              "en"
            )
          },
          data: {
            v2: $translate.instant("scan.report.data.V2", {}, "", "en"),
            v3: $translate.instant("scan.report.data.V3", {}, "", "en"),
            impactedVersion: $translate.instant(
              "scan.report.data.IMPACTED",
              {},
              "",
              "en"
            ),
            fixedVersion: $translate.instant(
              "scan.report.data.FIXED",
              {},
              "",
              "en"
            ),
            platforms: $translate.instant(
              "scan.report.data.PLATFORMS",
              {},
              "",
              "en"
            ),
            images: $translate.instant("scan.report.data.IMAGES", {}, "", "en"),
            nodes: $translate.instant("scan.report.data.NODES", {}, "", "en"),
            containers: $translate.instant(
              "scan.report.data.CONTAINERS",
              {},
              "",
              "en"
            )
          },
          others: {
            topImpactfulVulnerabilities: $translate.instant(
              "scan.report.others.TOP_IMPACTFUL_VUL",
              {},
              "",
              "en"
            ),
            reportSummary: $translate.instant(
              "audit.report.summaryHeader",
              {},
              "",
              "en"
            ),
            logoName: $translate.instant(
              "partner.general.LOGO_NAME",
              {},
              "",
              "en"
            ),
            topVulnerableImages: $translate.instant(
              "scan.report.others.TOP_VULNERABLE_IMAGES",
              {},
              "",
              "en"
            ),
            footerText: $translate.instant(
              "containers.report.footer",
              {},
              "",
              "en"
            ),
            headerText: $translate.instant(
              "partner.containers.report.header",
              {},
              "",
              "en"
            ),
            appendixText: $translate.instant(
              "scan.report.others.APPENDIX",
              {},
              "",
              "en"
            ),
            appendixDesc: $translate.instant(
              "scan.report.others.APPENDIX_DESC",
              {},
              "",
              "en"
            ),
            appendixPackagesText: $translate.instant(
              "scan.report.others.APPENDIX_PACKAGES",
              {},
              "",
              "en"
            ),
            appendixPackagesDesc: $translate.instant(
              "scan.report.others.APPENDIX_PACKAGES_DESC",
              {},
              "",
              "en"
            ),
            appendixText2: $translate.instant(
              "scan.report.others.APPENDIX2",
              {},
              "",
              "en"
            ),
            appendixDesc2: $translate.instant(
              "scan.report.others.APPENDIX_DESC2",
              {},
              "",
              "en"
            ),
            subTitleDetails: $translate.instant(
              "scan.report.others.DETAILS",
              {},
              "",
              "en"
            ),
            summaryRange: $translate.instant(
              "general.PDF_SUMMARY_RANGE_2",
              {
                rangedCount: options.filteredCount
              },
              "",
              "en"
            ),
            detailsLimit:
              options.filteredCount > $scope.REPORT_TABLE_ROW_LIMIT
                ? $translate.instant(
                    "general.PDF_TBL_ROW_LIMIT",
                    { max: $scope.REPORT_TABLE_ROW_LIMIT },
                    "",
                    "en"
                  )
                : "",
            KUBE: KUBE,
            OC: OC
          }
        };
      };

      const _getRowData = function(item, id, metadata) {
        let name = item.name;
        let description = item.description;
        let score = _getScore(item, metadata);
        let _packages = _getPackage(item, metadata);
        let publishedTime = _getPublishedTime(item);
        let impact = _getImpact(item, metadata);

        return [name, description, score, _packages, publishedTime, impact];
      };

      const _getPublishedTime = function(item) {
        return $filter("date")(
          item.published_timestamp * 1000,
          "MMM dd, y HH:mm:ss"
        );
      };

      const _getScore = function(item, metadata) {
        let scoreList = {};
        let scoreStyle = "";
        if (
          item.severity.toLowerCase() === "high" ||
          item.severity.toLowerCase() === "critical"
        ) {
          scoreStyle = "danger";
        } else if (
          item.severity.toLowerCase() === "medium" ||
          item.severity.toLowerCase() === "warning"
        ) {
          scoreStyle = "warning";
        } else {
          scoreStyle = "info";
        }
        scoreList.ul = [
          { text: `${metadata.data.v2}: ${item.score}`, style: scoreStyle },
          { text: `${metadata.data.v3}: ${item.score_v3}`, style: scoreStyle }
        ];
        return scoreList;
      };

      const _getPackage = function(item, metadata, isFullList) {
        let details = [];
        let packages = Object.entries(item.Packages);
        let originalPackageCount = packages.length;
        if (!isFullList) {
          packages = packages.slice(0, 3);
        }
        packages.forEach(([k, v]) => {
          let packageName = {};
          if (k) {
            packageName = {
              text: [k]
            };
          }

          let version;
          let impactedVersion = {};
          impactedVersion.ul = [];
          let fixedVersion = {};
          fixedVersion.ul = [];

          if (v && Array.isArray(v)) {
            v.forEach(package_version => {
              impactedVersion.ul.push(package_version.package_version);
              fixedVersion.ul.push(
                package_version.fixed_version
                  ? package_version.fixed_version
                  : "N/A"
              );
            });
          }
          version = {
            table: {
              widths: ["50%", "50%"],
              body: [
                [
                  { text: metadata.data.impactedVersion },
                  { text: metadata.data.fixedVersion }
                ],
                [impactedVersion, fixedVersion]
              ]
            },
            layout: {
              hLineColor: "gray",
              vLineColor: "gray"
            }
          };
          details.push([packageName, version]);
        });
        if (originalPackageCount > 3 && !isFullList) {
          details.push([{ text: `...... (${originalPackageCount} Packages)` }]);
        }
        return details;
      };

      const _getImpact = function(item, metadata) {
        let impactList = [];
        let platformList = {};
        platformList.ul = [];
        let imageList = {};
        imageList.ul = [];
        let nodeList = {};
        nodeList.ul = [];
        let containerList = {};
        containerList.ul = [];
        if (item.platforms && item.platforms.length > 0) {
          platformList.ul = item.platforms.map(
            platform => platform.display_name
          );
          impactList.push({ text: `${metadata.data.platforms}`, bold: true });
          if (platformList.ul.length > 5) {
            let omitedList = platformList.ul.slice(0, 5);
            omitedList.push(
              `......(${platformList.ul.length} ${metadata.data.platforms})`
            );
            impactList.push({ ul: omitedList });
            impactList.push(" ");
          } else {
            impactList.push(platformList);
            impactList.push(" ");
          }
        }
        if (item.images && item.images.length > 0) {
          imageList.ul = item.images.map(image => image.display_name);
          impactList.push({ text: `${metadata.data.images}`, bold: true });
          if (imageList.ul.length > 5) {
            let omitedList = imageList.ul.slice(0, 5);
            omitedList.push(
              `......(${imageList.ul.length} ${metadata.data.images})`
            );
            impactList.push({ ul: omitedList });
            impactList.push(" ");
          } else {
            impactList.push(imageList);
            impactList.push(" ");
          }
        }
        if (item.nodes && item.nodes.length > 0) {
          nodeList.ul = item.nodes.map(node => node.display_name);
          impactList.push({ text: `${metadata.data.nodes}`, bold: true });
          if (nodeList.ul.length > 5) {
            let omitedList = nodeList.ul.slice(0, 5);
            omitedList.push(
              `......(${nodeList.ul.length} ${metadata.data.nodes})`
            );
            impactList.push({ ul: omitedList });
            impactList.push(" ");
          } else {
            impactList.push(nodeList);
            impactList.push(" ");
          }
        }
        if (item.workloads && item.workloads.length > 0) {
          containerList.ul = item.workloads.map(
            workload => workload.display_name
          );
          impactList.push({ text: `${metadata.data.containers}`, bold: true });
          if (containerList.ul.length > 5) {
            let omitedList = containerList.ul.slice(0, 5);
            omitedList.push(
              `......(${containerList.ul.length} ${metadata.data.containers})`
            );
            impactList.push({ ul: omitedList });
          } else {
            impactList.push(containerList);
          }
        }
        return impactList;
      };

      function run(fn) {
        try {
          return new Worker(URL.createObjectURL(new Blob(["(" + fn + ")()"])));
        } catch (err) {
          console.log(err);
        }
      }

      const _webWorkerJob = function() {
        let dateStart = new Date();
        console.log("Worker is starting...", dateStart.toTimeString());
        const showProgress = (function(self) {
          return function(progress) {
            if (Math.floor(progress * 100000) % 1000 === 0) {
              self.postMessage({ progress: progress });
            }
          };
        })(self);
        self.onmessage = event => {
          let docDefinition = JSON.parse(event.data);

          docDefinition.header = function(currentPage) {
            if (currentPage === 2 || currentPage === 3) {
              return docDefinition.headerData;
            }
          };

          docDefinition.footer = function(currentPage) {
            if (currentPage > 1) {
              return {
                stack: [
                  docDefinition.footerData.line,
                  {
                    text: [
                      { text: docDefinition.footerData.text, italics: true },
                      { text: " |   " + currentPage }
                    ],
                    alignment: "right",
                    style: "pageFooter"
                  }
                ]
              };
            }
          };

          let drawReportInWebWorker = function(docDefinition) {
            let baseURL = event.srcElement.origin;
            self.importScripts(
              baseURL + "/vendor/pdfmake/build/pdfmake.js",
              baseURL + "/vendor/pdfmake/build/vfs_fonts.js"
            );

            let report = pdfMake.createPdf(docDefinition);

            report.getBlob(
              function(blob) {
                let dateEnd = new Date();
                console.log("Worker is end...", dateEnd.toTimeString());
                self.postMessage({ blob: blob, progress: 1 });
                self.close();
              },
              { progressCallback: showProgress }
            );
          };
          drawReportInWebWorker(docDefinition);
        };
      };

      const sendData2Worker = function(vulnerabilities) {
        // $interval.cancel(timer);
        $scope.pdfBlob = null;
        //start - generate a pdf
        if ($scope.worker) {
          $scope.worker.terminate();
          console.info("killed an existing running worker...");
        }
        $scope.worker = run(_webWorkerJob);
        if ($scope.worker) {
          if (vulnerabilities) {
            setTimeout(function() {
              let vulnerabilities4Pdf = vulnerabilities.map(vulnerability => {
                vulnerability.workloads = vulnerability.workloads.filter(
                  workload => $scope.namespaceFilter(workload)
                );
                return vulnerability;
              });
              let docData = Object.assign(
                {},
                {
                  data:
                    vulnerabilities4Pdf.length >= $scope.REPORT_TABLE_ROW_LIMIT
                      ? vulnerabilities4Pdf.slice(
                          0,
                          $scope.REPORT_TABLE_ROW_LIMIT
                        )
                      : vulnerabilities4Pdf
                },
                {
                  metadata: _getI18NMessages({
                    filteredCount: vulnerabilities.length,
                    rangedCount: $scope.count4Pdf
                  })
                },
                { images: imageMap }, //Picture URI code which is used in PDF
                { charts: getChartsForPDF() },
                { distByLevel: $scope.distByLevel },
                { distByName: $scope.distByName },
                { rowLimit: $scope.REPORT_TABLE_ROW_LIMIT }
              );
              console.log("Post message to worker...");
              $scope.worker.postMessage(
                JSON.stringify(_formatContent(docData))
              );
            }, 2000);
          } else {
            console.warn("no data in vulnerability.");
          }
          $scope.worker.onmessage = event => {
            $scope.pdfBlob = event.data.blob;
            $scope.progress = Math.floor(event.data.progress * 100);
            $scope.$apply();
          };
        } else {
          $scope.progress = 100;
        }
      };

      $scope.$on("$destroy", function() {
        $interval.cancel(timer);
        $interval.cancel(timer2);
        $scope.pdfBlob = null;
        $scope.pdfBlob2 = null;
        if ($scope.worker) {
          $scope.worker.terminate();
        }
        if ($scope.worker2) {
          $scope.worker2.terminate();
        }
      });

      /*==============================================================================
DF code end
===============================================================================*/
    }
  }
})();
