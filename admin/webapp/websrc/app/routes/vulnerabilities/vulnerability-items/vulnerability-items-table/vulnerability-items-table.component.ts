import {
  ChangeDetectorRef,
  Component,
  EventEmitter,
  OnDestroy,
  OnInit,
  Output,
} from '@angular/core';
import { CfgType, RemoteGridApi, VulnerabilityQuery } from '@common/types';
import {
  ColDef,
  GridApi,
  GridOptions,
  GridReadyEvent,
  ICellRendererParams,
  IGetRowsParams,
  ValueFormatterParams,
} from 'ag-grid-community';
import { TranslateService } from '@ngx-translate/core';
import { VulnerabilityItemsTableActionCellComponent } from './vulnerability-items-table-action-cell/vulnerability-items-table-action-cell.component';
import { VulnerabilityItemsTableImpactCellComponent } from './vulnerability-items-table-impact-cell/vulnerability-items-table-impact-cell.component';
import { VulnerabilityItemsTableScoreCellComponent } from './vulnerability-items-table-score-cell/vulnerability-items-table-score-cell.component';
import { VulnerabilityItemsTableSevertiyCellComponent } from './vulnerability-items-table-severtiy-cell/vulnerability-items-table-severtiy-cell.component';
import { VulnerabilitiesService } from '../../vulnerabilities.service';
import { VulnerabilitiesFilterService } from '../../vulnerabilities.filter.service';
import { MatDialog, MatDialogRef } from '@angular/material/dialog';
import { VulnerabilityItemsTableFilterComponent } from './vulnerability-items-table-filter/vulnerability-items-table-filter.component';
import {
  debounceTime,
  distinctUntilChanged,
  map,
  tap,
  retry,
  retryWhen,
  shareReplay,
  take,
  delayWhen,
} from 'rxjs/operators';
import { FormControl } from '@angular/forms';
import { of, timer } from 'rxjs';

@Component({
  selector: 'app-vulnerability-items-table',
  templateUrl: './vulnerability-items-table.component.html',
  styleUrls: ['./vulnerability-items-table.component.scss'],
})
export class VulnerabilityItemsTableComponent
  implements OnInit, OnDestroy, RemoteGridApi
{
  @Output() toggleChartView = new EventEmitter();
  @Output() vulnerabilitySelected = new EventEmitter();

  readonly PRELOAD_PAGE_NUMBER = 2;

  domains!: string[];
  cfgType!: CfgType;
  selectedVulnerability;
  matchTypes = this.vulnerabilitiesFilterService.matchTypes;
  dateTypes = this.vulnerabilitiesFilterService.dateTypes;
  quickFilter = new FormControl('');
  gridOptions!: GridOptions;
  gridApi!: GridApi;
  remoteGridBinding = this;
  filterDialog!: MatDialogRef<any>;
  filterOpen = false;
  lastLoadedRowsParams!: IGetRowsParams;
  cachedData: {
    [key: number]: { startRow: number; endRow: number; data: any[] };
  } = {};

  get activeScore() {
    return this.vulnerabilitiesFilterService.selectedScore === 'V2'
      ? this.translate.instant('scan.gridHeader.SCORE_V2')
      : this.translate.instant('scan.gridHeader.SCORE_V3');
  }

  get totalCount() {
    return this.vulnerabilitiesService.activeCount;
  }
  get filteredCount() {
    return this.quickFilter.value
      ? this.vulnerabilitiesFilterService.qfCount
      : this.vulnerabilitiesFilterService.filteredCount;
  }
  columnDefs: ColDef[] = [
    {
      field: '-',
      hide: true,
      lockVisible: true,
      filter: 'agTextColumnFilter',
      filterParams: {
        newRowsAction: 'keep',
      },
    },
    {
      field: 'name',
      sortable: true,
      resizable: true,
      headerValueGetter: () => this.translate.instant('scan.gridHeader.NAME'),
    },
    {
      field: 'severity',
      hide: true,
    },
    {
      field: 'score',
      hide: true,
      sortable: true,
      resizable: true,
      cellRenderer: 'scoreCellRenderer',
      cellRendererParams: {
        type: 'V2',
      },
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.SCORE_V2'),
      width: 140,
      maxWidth: 140,
      minWidth: 140,
    },
    {
      field: 'score_v3',
      sortable: true,
      resizable: true,
      cellRenderer: 'scoreCellRenderer',
      cellRendererParams: {
        type: 'V3',
      },
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.SCORE_V3'),
      width: 140,
      maxWidth: 140,
      minWidth: 140,
    },
    {
      field: 'published_timestamp',
      sortable: true,
      resizable: true,
      valueFormatter: this.dateFormatter,
      headerValueGetter: () =>
        this.translate.instant('scan.gridHeader.PUBLISHED_TIME'),
      width: 130,
      maxWidth: 150,
      minWidth: 130,
    },
    {
      colId: 'impact',
      sortable: true,
      resizable: true,
      cellRenderer: 'impactCellRenderer',
      headerValueGetter: () => this.translate.instant('scan.gridHeader.VICTIM'),
    },
    {
      resizable: true,
      cellRenderer: 'actionCellRenderer',
      cellRendererParams: {
        showInfo: event => this.showInfo(event),
      },
      cellClass: ['d-flex', 'align-items-center', 'justify-content-end'],
      headerValueGetter: () => this.translate.instant('setting.ACTIONS'),
      width: 150,
      maxWidth: 160,
      minWidth: 150,
    },
  ];

  constructor(
    private translate: TranslateService,
    private cd: ChangeDetectorRef,
    private vulnerabilitiesService: VulnerabilitiesService,
    private vulnerabilitiesFilterService: VulnerabilitiesFilterService,
    public dialog: MatDialog
  ) {}

  ngOnInit(): void {
    this.vulnerabilitiesService.getProfileType().subscribe(cfgType => {
      this.vulnerabilitiesService.setCfgType(cfgType);
    });

    this.vulnerabilitiesService.getDomain().subscribe(domains => {
      this.domains = domains;
    });
    this.gridOptions = {
      headerHeight: 30,
      rowHeight: 30,
      columnDefs: this.columnDefs,
      suppressDragLeaveHidesColumns: true,
      rowSelection: 'single',
      pagination: true,
      rowModelType: 'infinite',
      cacheBlockSize: this.vulnerabilitiesFilterService.paginationBlockSize,
      paginationPageSize: this.vulnerabilitiesFilterService.paginationPageSize,
      onGridReady: event => this.onGridReady(event),
      onSelectionChanged: event => this.onSelectionChanged(event),
      components: {
        impactCellRenderer: VulnerabilityItemsTableImpactCellComponent,
        actionCellRenderer: VulnerabilityItemsTableActionCellComponent,
        scoreCellRenderer: VulnerabilityItemsTableScoreCellComponent,
        severityCellRenderer: VulnerabilityItemsTableSevertiyCellComponent,
      },
      overlayNoRowsTemplate: this.translate.instant('general.NO_ROWS'),
    };
    this.quickFilter.valueChanges
      .pipe(debounceTime(500), distinctUntilChanged())
      .subscribe(filterText => {
        this.cachedData = {};
        this.gridApi.setFilterModel({ '-': { filter: filterText } });
      });
  }

  getData(params: IGetRowsParams) {
    const requestedPage = Math.floor(
      params.startRow / this.vulnerabilitiesFilterService.paginationPageSize
    );

    if (
      this.cachedData[requestedPage] &&
      this.isSameArray(this.lastLoadedRowsParams.sortModel, params.sortModel)
    ) {
      const cachedPageData = this.cachedData[requestedPage];
      console.log('cachedPageData.data', cachedPageData.data);
      return of({
        data: cachedPageData.data.slice(
          params.startRow - cachedPageData.startRow,
          params.endRow - cachedPageData.startRow
        ),
        totalRecords: this.quickFilter.value
          ? this.vulnerabilitiesFilterService.qfCount
          : this.vulnerabilitiesFilterService.filteredCount,
      });
    }

    if (!this.vulnerabilitiesService.activeToken) {
      return of({
        data: [],
        totalRecords: 0,
      });
    } else {
      this.lastLoadedRowsParams = params;


      return this.vulnerabilitiesService
        .getVulnerabilitiesPage(
          params.startRow,
          params.sortModel,
          params.filterModel
        )
        .pipe(
          tap(sessionData => {
            this.vulnerabilitiesFilterService.qfCount =
              sessionData.qf_matched_records;
          }),
          map(sessionData => {
            const data = {
              data: this.vulnerabilitiesService.extractPodImage(
                sessionData.vulnerabilities
              ),
              totalRecords: this.quickFilter.value
                ? this.vulnerabilitiesFilterService.qfCount
                : this.vulnerabilitiesFilterService.filteredCount,
            };

            if (!this.cachedData[requestedPage]) {
              this.cachedData[requestedPage] = {
                startRow: params.startRow,
                endRow: params.endRow,
                data: data.data,
              };
            }

            return data;
          }),
          shareReplay(),
          retryWhen(errors => {
            return errors.pipe(
              delayWhen(() => timer(1000)),
              take(5),
              tap(() => console.log('retrying...'))
            );
          })
        );
    }
  }

  changeScoreView(val: string) {
    this.vulnerabilitiesFilterService.selectedScore = val;
    if (val === 'V2') {
      this.gridApi?.setColumnVisible('score_v3', false);
      this.gridApi?.setColumnVisible('score', true);
    } else {
      this.gridApi?.setColumnVisible('score', false);
      this.gridApi?.setColumnVisible('score_v3', true);
    }
    this.gridApi.sizeColumnsToFit();
    this.cd.markForCheck();
  }

  onGridReady(params): void {
    this.gridApi = params.api;
    this.vulnerabilitiesService.gridApi = this.gridApi;

    setTimeout(() => {
      this.changeScoreView(this.vulnerabilitiesFilterService.selectedScore);
      this.gridApi.sizeColumnsToFit();
      this.cd.markForCheck();
    }, 500);
  }

  onModelUpdated() {
    const firstRowNode = this.gridApi.getDisplayedRowAtIndex(0);
    if (firstRowNode) {
      firstRowNode.setSelected(true);
    }

    this.preloadPages(this.PRELOAD_PAGE_NUMBER);
  }

  onResize(): void {
    this.gridApi.sizeColumnsToFit();
  }

  onSelectionChanged(params: GridReadyEvent): void {
    this.toggleChartView.emit(false);
    this.selectedVulnerability = params.api.getSelectedNodes()[0]?.data;
    this.vulnerabilitiesService.selectVulnerability(
      params.api.getSelectedNodes()[0]?.data
    );
  }

  showInfo(params: ICellRendererParams): void {
    if (params.data) this.vulnerabilitySelected.emit(params.data);
  }

  onToggleChartView() {
    this.toggleChartView.emit();
  }

  openAdvancedFilter(): void {
    if (!this.filterOpen) {
      this.filterOpen = true;
      this.filterDialog = this.dialog.open(
        VulnerabilityItemsTableFilterComponent,
        {
          width: '675px',
          data: {
            filter: this.vulnerabilitiesFilterService.vulQuerySubject$.value,
            domains: this.domains,
          },
          hasBackdrop: false,
          position: { right: '25px', top: '100px' },
        }
      );
      this.filterDialog
        .afterClosed()
        .subscribe((filter: VulnerabilityQuery) => {
          if (filter) {
            this.vulnerabilitiesService.refreshing$.next(true);
            if ((filter as any).reset) {
              this.setAdvancedFilter();
            } else {
              this.setAdvancedFilter(filter);
            }
          }
          this.filterOpen = false;
        });
    }
  }

  setAdvancedFilter(filter?: VulnerabilityQuery) {
    if (filter) {
      this.vulnerabilitiesFilterService.vulQuerySubject$.next({
        ...this.vulnerabilitiesFilterService.vulQuerySubject$.value,
        ...filter,
      });
    } else {
      this.vulnerabilitiesFilterService.vulQuerySubject$.next({
        ...this.vulnerabilitiesFilterService.initVulQuery(),
        viewType:
          this.vulnerabilitiesFilterService.vulQuerySubject$.value.viewType,
      });
    }
  }

  dateFormatter(params: ValueFormatterParams): string {
    if (!params.data) return '';
    const date = new Date(params.data.published_timestamp * 1000);
    const dateString = date.toDateString().split(' ').slice(1);
    dateString[1] = dateString[1] + ',';
    return dateString.join(' ');
  }

  ngOnDestroy() {
    if (this.filterOpen) {
      this.filterDialog.close();
    }
  }

  private isSameArray(arr1: any[], arr2: any[]) {
    if (arr1.length !== arr2.length) return false;
    const sortedArr1 = arr1.map(obj => JSON.stringify(obj)).sort();
    const sortedArr2 = arr2.map(obj => JSON.stringify(obj)).sort();

    return sortedArr1.every((obj1, index) => obj1 === sortedArr2[index]);
  }

  private preloadPages(gap: number) {
    if (!this.gridApi) {
      return;
    }

    const currentPage = this.gridApi.paginationGetCurrentPage();

    for (let i = 1; i <= gap; i++) {
      this.preloadPage(currentPage + i);
      this.preloadPage(currentPage - i);
    }
  }

  private preloadPage(pageIndex: number) {
    const totalRecords = this.vulnerabilitiesService.activeCount;
    const startRow =
      pageIndex * this.vulnerabilitiesFilterService.paginationPageSize;
    const endRow =
      startRow + this.vulnerabilitiesFilterService.paginationPageSize;

    if (
      !this.cachedData[pageIndex] &&
      pageIndex >= 0 &&
      startRow < totalRecords
    ) {
      this.getData({
        ...this.lastLoadedRowsParams,
        startRow: startRow,
        endRow: endRow,
        filterModel: this.gridApi.getFilterModel(),
      }).subscribe();
    }
  }
}
